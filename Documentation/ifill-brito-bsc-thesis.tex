\documentclass[type=bsc,accentcolor=tud9c]{tudthesis}
\usepackage[utf8]{inputenc}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{mdframed}
\usepackage{array}
\usepackage{minted}
\usepackage{tikz}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{chngcntr}
\usepackage{enumitem}
\usepackage{longtable}
\usepackage{subcaption}
\usepackage{rotating}
\usepackage[doublespacing]{setspace}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows,shapes,positioning,shadows,trees} % x-y Diagrams
\usepackage{tikz-uml}

\newcommand{\framework}[1]{\textcolor{black}{#1}}
\usemintedstyle{trac}
\input{preamble.tex}
\newcommand{\toolcore}{\textsc{2Rx}}
\newcommand{\toolextension}{\textsc{SwingWorker2Rx}}
\newcommand{\toolrxfactor}{\textsc{AsyncTask2Rx}}


\begin{document}
%\setstretch{2.5}% for comments
\setstretch{1}% normal
\counterwithin{lstlisting}{chapter}
\counterwithin{figure}{chapter}
\counterwithin{table}{chapter}
\setlist[itemize]{noitemsep}
\setlist[itemize]{nolistsep}
\setlist[enumerate]{noitemsep}
\setlist[enumerate]{nolistsep}

\thesistitle{Automated Refactoring for Asynchronous Applications}{}
\author{Grebiel Jos√© Ifill Brito}
\birthplace{Caracas, Venezuela}
\date{February 2017}
\referee{Prof. Dr. Guido Salvaneschi}{M.Sc. Pascal Weisenburger}
\department{Computer Science}
\group{Reactive Programming Technology}

\makethesistitle

\chapter*{Abstract}
Modern languages are replacing the traditional callback-based approach with event-driven, reactive and functional programming models. According to previous studies, these programming paradigms improve code writing and code comprehension.

Motivated by these facts, we propose a refactoring approach to convert a callback-based async construct into functional reactive programming code. This thesis focuses on refactoring the \code{SwingWorker} \framework{Java} Swing construct.

We developed \toolextension{}, a system to perform the mentioned refactoring automatically.

We evaluate the accuracy of \toolextension{} using 58 projects. In these projects there are 678 elements (declarations, instances, invocations, methods, variables, fields, among others) that contained the target async construct. Our tool successfully refactored 676 of these elements, which represents approximately 99.7\%. These results show that the tool is highly accurate.

\tableofcontents
\listoffigures
\listoftables
\listoflistings


\chapter{Introduction}
\label{chapter:introduction}
Asynchronous programming refers to the execution of program code in multiple threads. These threads run concurrently. Synchronous programming, on the contrary, refers to the sequential execution of program code in a single thread. Most UI frameworks are single threaded~\cite{uiSingleThreaded}. When a long-running operation is executed in the UI thread, then the user interface freezes until the operation has completed. This happens because all commands in the UI thread are executed sequentially. To avoid this blocking behavior, developers use asynchronous programming, which allows them to execute the long-running operation in a background thread. Since the background and the UI thread run concurrently, the UI thread remains responsive.

Several tools have been developed in the last years to automatically refactor the source code of asynchronous applications. \textsc{Asynchronizer}~\cite{paperRetrofittingConcurrency}, \textsc{AsyncDroid}~\cite{paperStudyRefactoring}, \textsc{Asyncifier}~\cite{paperAsyncMobile}, \textsc{AsyncFixer}~\cite{paperAsyncMobile}, \textsc{PromisesLand}~\cite{thesisJavaScript} and \textsc{RxFactor}~\cite{thesisRxFactor} are some of these tools. Each of them solves different problems. \textsc{Asynchronizer} and \textsc{AsyncDroid} focus on performance improvement in \framework{Android} applications, while \textsc{Asyncfier} and \textsc{PromissesLand} aim increasing the code readability in \framework{C\#} and \framework{JavaScript} respectively. \textsc{AsyncFixer} helps finding and correcting anti patterns of async constructs in \framework{C\#}. Finally \textsc{RxFactor} is a refactoring tool that converts \code{AsyncTask}s into an implementation that uses the \framework{ReactiveX} API. \textsc{RxFactor} was developed parallel to this thesis by another author.

On the other hand, functional programming has been gaining popularity in the last years. \framework{Java 8}, for example, offers several classes to support working with data streams in a functional fashion~\cite{bookJava8Streams}. Other technologies such as \framework{Flapjax}, \framework{ReactiveX} and \framework{Agera} are not only using functional concepts but also focusing on the reactive programming paradigm. \framework{Flapjax} is a programming language that introduces event-driven reactivity as the natural programming model for web applications~\cite{paperFlapjax}. \framework{ReactiveX} is a library based on the observer pattern that supports data streams and functional programming~\cite{reactiveX}. \framework{Agera} also offers classes for functional, asynchronous and reactive programming in \framework{Android} applications~\cite{agera}.

According to previous researches, reactive and functional programming models improve code writing and code comprehension~\cite{promises, paperReactiveComprehension}. One can refactor existing applications in other to facilitate the implementation of these models. Depending on the size of the projects and the amount, the refactoring task can demand a lot of effort. Implementing tools to perform the refactorings automatically minimizes this effort and allows developers focusing on new features which can be added using reactive and functional programming concepts.

\section{Contribution}

In this thesis, we show how a traditional callback-based async construct can be refactored into another construct that facilitates the implementation of reactive and functional programming models. Since performing these refactorings by hand in multiple or large projects demands a lot of time, we designed a tool to accomplish this task.

We focus on refactoring \code{SwingWorker}s into an implementation that uses the \framework{ReactiveX} API for \framework{Java} (\framework{RxJava}). To perform the refactorings automatically, we developed a tool called \toolcore{}. One can easily add extensions to this tool. We implemented \toolextension{}, which can convert \code{SwingWorker}s to \framework{RxJava}. Additionally, we adapted \textsc{RxFactor}, a similar tool that converts \code{AsyncTask}s into \framework{RxJava}, to make it a client of \toolcore{} as well. Although \textsc{RxFactor} and \toolextension{} are very similar, the refactoring approaches are different. The approach proposed in this thesis overcomes the following weaknesses of \textsc{RxFactor}: Not supporting all methods available in the \code{AsyncTask} API; Vulnerable to backpressure problems.

Contribution summary:
\begin{itemize}
	\item A refactoring approach to convert \code{SwingWorker}s into \framework{RxJava}
	\item A system to host refactoring tools (\toolcore{})
	\item A client of \toolcore{} responsible for refactoring \code{SwingWorker}s into \framework{RxJava} (\toolextension{})
	\item A client of \toolcore{} responsible for refactoring \code{AsyncTask} into \framework{RxJava} based on the implementation of \textsc{RxFactor}
\end{itemize}


\section{Structure}
The thesis is structured as follows: Chapter~\ref{chapter:stateOfTheArt} provides some background about refactoring, asynchronous programming, the observer pattern, and functional and reactive programming. In this chapter we explain the \code{SwingWorker} API, followed by the state of the art in automated refactoring for asynchronous applications. Finally, we talk about modern technologies that use event-driven, reactive and/or functional programming concepts. We show the design of the refactoring approach and \toolcore{} in Chapter~\ref{chapter:design}. The implementation details are explained in Chapter~\ref{chapter:implementation}. In Chapter~\ref{chapter:evaluation} we present the evaluation and its results and in Chapter~\ref{chapter:conclusion} we summarize the work, present our conclusion and recommendations for future research on this topic.

\chapter{State of the Art}
\label{chapter:stateOfTheArt}
Asynchronous programming refers to the execution of program code in multiple threads. Since most UI frameworks are single threaded~\cite{uiSingleThreaded}, developers use asynchronous programming to improve the responsiveness of the UI. This improvement is accomplished by executing long-running operations on a background thread ~\cite{paperAsyncMobile, asyncProgramming}.

In Figure~\ref{fig:sync-vs-async} we illustrate how asynchronous programming is used in order to avoid that a long-running operation blocks the user interface. In the diagram, we compare the synchronous and asynchronous execution of three operations. The first operation requires more time than the other two. In Figure~\ref{fig:sync} the longest operation is executed first. After that, \code{operation2} and \code{operation3} are triggered. As we can see, \code{operation2} and \code{operation3} cannot be executed immediately because the UI thread is busy. These operations can be anything, for example, UI events. Since the thread cannot process these events, the system is said to be unresponsive. Figure~\ref{fig:async} shows how we can solve this problem by using a background thread. Basically, long-running operations are passed to a different thread. As we can see in the diagram, while \code{operation1} is performed in the background thread, the UI thread remains free and can execute other operations. Eventually, when the long-running operation has completed, the result is sent to the main thread. It is important to consider that delegating operations to background threads generates overhead. This overhead is represented with two small black rectangles.

\begin{figure}[h]
\begin{center}
\begin{subfigure}{0.4\textwidth}
\includegraphics[height=6cm]{asynchrony/sync.png}
\caption{Synchronous}
\label{fig:sync}
\end{subfigure}
\begin{subfigure}{0.4\textwidth}
\includegraphics[height=6cm]{asynchrony/async.png}
\caption{Asynchronous}
\label{fig:async}
\end{subfigure}
\end{center}
\caption{Synchronous vs. Asynchronous Execution}
\label{fig:sync-vs-async}
\end{figure}

Listings~\ref{code:asyncRunnableExample} and~\ref{code:asyncFutureExample} are two examples of asynchronous programming in \framework{Java}. The implementation of Listing~\ref{code:asyncRunnableExample} is fire and forget, which means, that no result is expected. The asynchronous operation starts in Line 4 and the rest of the code keeps running sequentially, regardless of the amount of time required to finish the asynchronous operation. The implementation of Listing~\ref{code:asyncFutureExample} does return a result. The asynchronous operation starts in Line 4 and the result is retrieved in Line 9. These examples are used in the next sections to explain the concepts of data races and promises, also called futures.

\input{code-examples/java-async-example.tex}

\section{Data Races}
Asynchronous implementations and shared memory models are vulnerable to data races. A data race occurs when multiple threads write a variable in an unspecific order \cite{bookDataRaces}. Since the order in which threads are executed is not well-defined, the result of the modified variable is non-deterministic. To avoid this problem, the developer has to implement locks to make sure that the order of execution is deterministic.

In Listing~\ref{code:asyncRunnableExample} there are two operations that run concurrently, \code{performOpAsync} and \code{performOperation}. Assuming that these methods modify a variable \code{var} and that there is no synchronization mechanism, then we have a data race because we cannot tell for sure which operation modified the value at last. The same happens in Listing~\ref{code:asyncFutureExample} with \code{computeResult} and \code{performOperation}.

\section{Promises}
Promises, also known as Futures, are language constructs that are used to synchronize concurrent code. These constructs consist of a reference to the result of a running operation~\cite{promisesDef}.

In \framework{JavaScript} for example, \framework{Promise}s can be \code{pending} (not started), \code{fulfilled} (successful operation) or \code{rejected} (failed operation) ~\cite{promises}. Since \framework{Promise}s can be chained together, developers need not to use traditional callback-based approaches to handle the return values. According to previous studies, chained calls are easier to understand than callback-based approaches ~\cite{promisesSpring}.

Listing~\ref{code:asyncFutureExample} shows an example of Futures in \framework{Java}. First the \code{task} is executed by the \code{ExecutorService} in a background thread. This call returns the reference to the object that contains the result, in this case, called \code{future}. Then, a second operation called \code{performOperation}, runs in the current thread. After this last operation has completed, we are ready to read the result from the asynchronous task. If the result is not available, then this call waits until the result has been computed. Otherwise, it writes the result in the variable \code{asyncResult} and continues the execution of the next lines of code.

\section{Automated Refactoring}
\label{sec:automated-refactoring}
Refactoring consists of modifying the source code of a program without changing its behavior. Refactoring can be applied to extract a reusable component, improve consistency among components, supporting new features, among others ~\cite{thesisRefactoringFrameworks}. 

Many IDEs already offer refactoring tools. Some of the common refactoring commands are: rename; move; change method signature; extract methods, local variables, constants, interfaces, superclass; among others ~\cite{eclipse, intelliJ}. 

On the other hand, researchers have been developing tools to refactor asynchronous applications. Some of the tools convert synchronous into asynchronous code. Other tools refactor asynchronous code that uses the traditional callback-based approach into method chaining~\cite{paperAsyncMobile, paperStudyRefactoring, thesisJavaScript, paperRetrofittingConcurrency}. We explain these tools in Section~\ref{sec:refactoring-tools}.

\subsection{Abstract Syntax Trees}
Abstract syntax trees (AST) are data structures that only contain the essential information about the source code. Each node corresponds to a construct of the specific language. Some examples of these constructs in Java are: assignment, field declaration, variable declaration, method declaration, class instance creation, type declaration, if-statement, try-statement, anonymous class declaration, body declaration, catch clause, among others. In contrast to parse trees, ASTs does not contain the symbols required to compile the code, such as "\{", "\}", ";", among others~\cite{bookAST}. Figure~\ref{fig:ast-vs-parser-tree} shows the difference between both types of trees.

\input{tikz-images/ast-vs-parser-tree.tex}

As we mentioned in Section~\ref{sec:automated-refactoring}, most IDEs offer refactoring tools. Eclipse, for example, uses AST to get details about the source code and write or modify changes in it (Figure~\ref{fig:ast}).

\section{Functional Programming}
Functional programming is a programming paradigm that uses mathematical functions as its main programming construct~\cite{bookFunctionalProgramming}. This paradigm avoids using concepts such as state and mutable data. Avoiding these concepts facilitates implementation, testing, debugging and code comprehension~\cite{bookFunctionalProgrammingScala}.

In Listings~\ref{code:imperative-pro} and~\ref{code:functional-pro} we compare imperative and functional programming. One can see, that the functional implementation is much compacter than the imperative one. However, this does not apply for every case. Developers must reason about which of these paradigms are more suitable to the given problem.

\input{code-examples/functional-vs-imperative.tex}

\section{Event Driven Programming}
Event driven programming consists of program code that gets executed when an event occurs. Most Windows programs are a good example of this since they are written using event-driven models. If an event never occurs, then the piece of code associated with that event will never be executed. If there is no piece of code associated with an event, then the event will be ignored.~\cite{bookEventDrivenProgramming}.

\subsection{Reactive Programming}
Reactive programming is a programming paradigm that bases in the propagation of change. This programming model is considered a special case of the event-driven paradigm. The events refer mostly to data changes~\cite{bookLearningReactive}. In reactive programming, there is a data-flow graph that indicates how the changes are propagated.
 
Figure~\ref{fig:dataflow} illustrates how reactive programming works. The operation~$a + b$ produces the result~$r$. The first state is: $a=10$, $b=5$, $r=15$. In imperative programming, changing the values of~$a$ and/or~$b$ does not automatically affect the result~$r$, but in reactive programming that is not the case. If the value of~$a$~or~$b$ changes, the operation $+$ is performed and $r$ is updated. 

The previous example also shows a relation between the observer pattern and reactive programming. Let ~$a$ and~$b$ be the subjects and~$r$ be the observer.  If~$r$ updates its value every time~$a$~or~$b$ change, then the behavior described corresponds to a reactive program as well.

\input{tikz-images/reactiveProgramming.tex}

\section{Observer Pattern}
The idea of the observer pattern is to establish a one-to-many relationship between objects. The dependent objects are called observer. The independent objects or subjects notify their observers when their state change. This pattern allows developers modifying observers and subjects independently. Also, observers can be added without applying changes to the existing subject nor the other observers~\cite{bookDesignPatterns}.

The usage of the observer pattern in asynchronous applications can cause backpressure problems when the subject notifies changes faster than the observer's capacity to process them. There are several solutions to tackle this problem. One of them is to have a buffer to accumulate the data received from the subject. Since the buffer can get full, this solution does not work for every case. An alternative solution is to block the notifications from the subject until the data has been processed by the observer~\cite{rxJavaBackpressure}. The disadvantage of the last approach is that the subject is as fast as the slowest observer. A combination of both approaches is also possible.

\section{Reactive and/or Functional Technologies}
Empirical studies have shown that reactive programming increases the correctness of program comprehension without requiring neither more time to analyze the program nor advance programming skills~\cite{paperReactiveComprehension}. Furthermore, there are new technologies that are based on event-driven programming models and reactivity. \framework{Flapjax}, \framework{ReactiveX} and \framework{Agera} are some of them. These technologies also agree that reactive and event-driven approaches simplify code writing and comprehension~\cite{agera, reactiveX, paperFlapjax}.

\subsection{Flapjax}
\framework{Flapjax} is a language built on top of \framework{JavaScript} to enable event-driven programming. 
It can also be used as a library if developers do not want to use the Flapjax-to-JavaScript compiler~\cite{paperFlapjax}.

\framework{Flapjax} introduces two new data types, \code{Behavior}s and \code{Event-Stream}s. \code{Behavior}s are values that change over time  (i.e: a variable). Changes in \code{Behavior}s propagate automatically, facilitating developers consistency in their applications. \code{Event-Stream}s represent the input sources.~\cite{paperFlapjax}.

Listing~\ref{code:javaScript} shows a basic \framework{JavaScript} example where a string value \code{id="validationMessage"} (Line~31) is updated when an event \code{"onChange"} is triggered. Since there is no native \framework{JavaScript} call to determine if an input have changed, a possible (trivial) implementation could be for example triggering the \code{validateNumber} function every $200ms$ (Line~22). We chose this time interval because we consider it small enough to be perceived as an immediate change. Notice that the function \code{startValidation} must be called on load (Line~27). The validation logic is implemented in the function \code{validateNumber} (Line~5).

Listing~\ref{code:flapjax} shows the same example using \framework{Flapjax}. In this case, \framework{Flapjax} was downloaded and used as a library (Line~2). The implementation basically defines a behavior for the input \code{numb} (Line~7). The function \code{liftB} (Line~8) creates a time varying value which is used for updating the \code{validationMessage}. The function \code{loader} defines the events (Line~8) and their reaction (Line~20). This function is also called on load (Line~26). This example shows how \framework{Flapjax} allows keeping the UI consistency without having to implement a mechanism for updating a particular field. Instead, events and reaction to those events are defined.

More interactive examples can be found at \framework{Flapjax}'s official site~\cite{urlFlapjaxDemo}.

\code{Event-Stream}s can be processed in \framework{Flapjax} using functions such as: \code{mapE}, \code{mergeE}, \code{filterE}, \code{andE}, \code{orE}, \code{notE}, among others.

These functions are also available in \framework{ReactiveX}~\cite{reactiveX}.

\begin{figure}[]
\begin{minipage}{0.48\textwidth}
\begin{sourcecode}
\input{code-examples/javascript.tex}
\caption{JavaScript}
\label{code:javaScript}
\end{sourcecode}
\end{minipage}\hspace{0.75cm}
\begin{minipage}{0.49\textwidth}
\begin{sourcecode}
\input{code-examples/flapjax.tex}
\caption{Flapjax}
\label{code:flapjax}
\end{sourcecode}
\end{minipage}
\end{figure}


\subsection{ReactiveX}
\framework{ReactiveX} is a library that supports data streams and reactivity. It is available in many platforms (\framework{Java}, \framework{JavaScript}, \framework{C\#}, \framework{C++}, \framework{Ruby}, \framework{Android}, among others)~\cite{reactiveX}. 

\begin{figure}[]
\begin{sourcecode}
\input{code-examples/reactiveX.tex}
\caption{RxJava: Streams}
\label{code:rxJava-streams}
\end{sourcecode}
\end{figure}

The API of \framework{ReactiveX} for \framework{Java} programs is called \framework{RxJava}. By using \framework{RxJava} it is possible to write asynchronous programs in a functional fashion. Additionally, since \framework{RxJava} is based on the observer pattern, it is also possible to implement reactive models.

Listing~\ref{code:rxJava-streams} shows an example where we use \framework{RxJava} to select some items, transform them and save the newly generated items. We use a background thread for the operations and update the UI when done. The process is as follows: First, we create a \code{rx.Observable} object using the method \code{Observable.from} (Line~4). Then, we invoke further methods to modify the data stream (\code{filter}, \code{map}). After that, we specify in which thread the operation must be executed (Line~12). RxJava offers several \code{Scheduluer}s for that purpose. However, one can also use custom executors. Next, we define the save operation using \code{doOnNext} (Line~13). Since in this example the \code{doOnCompleted} operation must be executed in the UI thread, we place the \code{observeOn} declaration before \code{doOnCompleted} (Line~15). Finally, we subscribe the observable. This subscription starts executing the async operation.

\begin{figure}[t]
\begin{sourcecode}
\input{code-examples/reactiveX-reactive-code.tex}
\caption{RxJava: Reactive Code}
\label{code:rxJava-reactive-code}
\end{sourcecode}
\end{figure}

Listing~\ref{code:rxJava-reactive-code} shows an example where we use \framework{RxJava} to implement two reactive operations (addition and multiplication). The first step is to define the subjects (Lines 2-3). Then, we declare the subscribers (Lines 4-5), also called observers. Finally, we define the behavior (Lines 6-7). We do this by creating an observable that combines both subjects and defines the result. Then we subscribe the corresponding subscriber to each observable. Lines 11 and 14 show how we manipulate the subjects, so the changes are propagated to the subscribers.

\framework{RxJava} offers many other classes and methods for building asynchronous reactive models. Explaining all of them does not belong to the scope of this thesis. More information and examples about this library can be found at~\cite{bookLearningReactive}.

\subsection{Java 8}
\framework{Java 8} introduces a series of classes that allows working with data streams in a functional fashion~\cite{bookJava8Streams}. However, in contrast to \framework{RxJava}, the new classes of \framework{Java 8} do not support defining which operations should be executed in the background and which ones on the UI thread.

\input{code-examples/rxJava-vs-Java8.tex}

Listings~\ref{code:rxJava-compared} and~\ref{code:java8-compared} show a comparison between \framework{RxJava} and \framework{Java 8}. There are two method invocations that are identical and one invocation that is similar but not completely equivalent. Using functions such as \code{filter} and \code{map} can be done with both, \framework{RxJava} and \framework{Java 8}, in the same way. The call \code{doOnNext} is similar to \code{forEach} in the sense of iterating through all items and doing some operations with them. The big difference is that \code{forEach} actually starts executing the operation while \code{doOnNext} only defines it. In the second case the operation starts when the observable is subscribed (Listing~\ref{code:java8-compared}, Line 14). Also, \code{forEach} does not not allow chaining futher methods. Methods such as \code{subscribeOn}, \code{doOnError}, \code{observeOn}, \code{doOnCompleted}, among others have no equivalent in \framework{Java 8}.

\section{Async Constructs}
There are several async constructs in many different programming languages and libraries. We want to focus particularly in \code{SwingWorker}s because that is the construct that we analyze in this thesis. Additionally, we want to explain the basics about \code{AsyncTask}s because previous research has been analyzing them and developing refactoring tools for different purposes.

Figure~\ref{fig:asynctask-execution} illustrates in which threads the methods of an \code{AsyncTask} are executed. In this example, the \code{AsyncTask} starts with the invocation of \code{execute}. Then \code{onPreExecute} is invoked in the UI thread. As soon as this method finishes, \code{doInBackground} is invoked on a background thread. While the asynchronous operation is running, data can be sent to UI thread throw the invocation of \code{publish}. This data is processed in the UI thread using the logic specified in \code{onProgressUpdate}. The \code{publish} method can be invoked multiple times. Finally, when the asynchronous operation has completed, the result is processed in the UI thread using the \code{onPostExecute} method.

Figure~\ref{fig:swingWorker-execution} shows which methods of a \code{SwingWorker} are executed in the background and which ones in the UI thread. The \code{SwingWorker} also starts when \code{execute} is invoked. Notice that \code{SwingWorker}s do not have an \code{onPreExecute} method. Like \code{AsyncTask}s, \code{SwingWorker}s also have a \code{publish} method to send data to the UI thread. This data is processed according to the logic contained in the \code{process} method. The \code{publish} method can be called multiple times too. Finally, after the asynchronous operation has completed, the method \code{done} is invoked, which is also executed in the UI thread. Inside \code{done} the method \code{get} can be invoked, in order to have access to the result of the async operation.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\begin{center}
\includegraphics[height=6.5cm]{async-constructs/asynctask.png}
\end{center}
\caption{AsyncTask Execution}
\label{fig:asynctask-execution}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\begin{center}
\includegraphics[height=6.5cm]{async-constructs/swingworker.png}
\end{center}
\caption{SwingWorker Execution}
\label{fig:swingWorker-execution}
\end{subfigure}
\caption{AsyncTask vs. SwingWorker}
\end{figure}

\code{SwingWorker}s and \code{AsyncTask}s also have some similar methods. We match these methods in Table~\ref{table:worker-task-equivalent}. Methods written in {\bf bold} depend on the state of the \code{SwingWorker} and/or \code{AsyncTask}.

\begin{table}[h]
{\small
\begin{center}
\begin{tabular}{|C{6cm} | C{6cm}|}
\hline
\bf SwingWorker~\cite{swingworkerapi} & \bf AsyncTask~\cite{ulrAndroidAsyncTask}\\\hline
doInBackground() & doInBackground(...)\\
process(...) & onProgressUpdate(...)\\
publish(...) & publishProgress(...)\\
done() & onPostExecute(...)\\\hline
cancel(...) & cancel(...)\\
execute() & execute(...)\\
\bf getState() & \bf getStatus()\\
\bf isCancelled() & \bf isCancelled()\\
get() & get() \\
get(...) & get(...)\\\hline
\end{tabular}
\end{center}
\caption{Equivalent Methods - SwingWorker vs. AsyncTask (1)}
\label{table:worker-task-equivalent}
}
\end{table}

However, not all methods have an equivalent. Table~\ref{table:worker-task-non-equivalent} shows all methods that do not have a match. Again, methods written in {\bf bold} depend on the state of the class. As we can see, \code{SwingWorker}s have more methods that depend on the state than \code{AsyncTask}s. This point will be discussed again in Chapter~\ref{chapter:design}, when we talk about the refactoring approach that we use to convert \code{SwingWorker}s into \framework{RxJava}.

\begin{table}[h]
{\small
\begin{center}
\begin{tabular}{|C{6cm} | C{6cm}|}
\hline
\bf SwingWorker~\cite{swingworkerapi} & \bf AsyncTask~\cite{ulrAndroidAsyncTask}\\\hline
\bf addPropertyChangeListener(...) & --\\
\bf firePropertyChange(...) & --\\
\bf getProgress() & --\\
\bf getPropertyChangeSupport() & --\\
\bf isDone() & --\\
\bf removePropertyChangeListener(...)& --\\
run()& --\\
\bf setProgress(...)& --\\\hline
-- & onPreExecute() \\
-- & executeOnExecutor(...)\\
-- & onCancelled()\\\hline
\end{tabular}
\end{center}
\caption{Equivalent Methods - SwingWorker vs. AsyncTask (2)}
\label{table:worker-task-non-equivalent}
}
\end{table}

For more details about the \code{SwingWorker} API go to Appendix~\ref{swingworkerapi}. 

\section{Refactoring Tools}
\label{sec:refactoring-tools}
Modern programming languages such as \framework{C\#}, \framework{Visual Basic}, \framework{F\#} and \framework{Scala} have introduced \code{asycn} constructs and \code{await} calls to facilitate the implementation of asynchrony. With these constructs developers do not need to implement callbacks to manage asynchrony \cite{paperAsyncMobile}. 

According to previous studies, async constructs are being underused or misused. A common example of misused asynchrony is to introduce elements that appear to be asynchronous, but due to semantic mistakes, the code still runs synchronously. To tackle this problem, refactoring tools have been developed~\cite{paperAsyncMobile}. 

Refactoring asynchronous applications is not trivial. Therefore researchers have already started developing tools to assist developers in this task. These tools can be classified into three groups:

\begin{enumerate}
	\item Synchronous code $\rightarrow$ asynchronous code
	\item Callback based asynchronous code $\rightarrow$ method chained asynchronous code
	\item Correction of anti-patterns and performance improvements
\end{enumerate}

\subsection{Synchronous $\rightarrow$ Asynchronous}
According to a previous research, refactoring synchronous \framework{Android} applications to be asynchronous is not an easy task~\cite{paperAsyncMobile}. The author of this work, Danny Dig, mentions two main reasons that difficulties this refactoring task. The first one is that most documentation focuses on the design from scratch, rather than on the process of converting synchronous code into asynchronous and the second one is that there are not enough methods neither tools to perform this kind of refactoring.

Motivated by these facts, the author developed \textsc{Asynchronizer}. \textsc{Asynchronizer} targets \framework{Android} applications. It can be used to convert synchronous code into asynchronous by using an \code{AsyncTask}~\cite{paperRetrofittingConcurrency}. \textsc{Asynchronizer} basically moves the synchronous code into the \code{doInBackground} method of the \code{AsyncTask}. Then it analyzes the rest of the code in order to determine which part can be placed into the \code{onPostExecute} handler. Finally, it creates an instance of the class in the main thread and calls its \code{execute} method.

Converting synchronous code into asynchronous might produce data races. To make sure that there are no data races after refactoring, they implemented an extension of the \textsc{IteRace} detector. This component is included with \textsc{Asynchronizer}. It is important to mention that this check does not run automatically. Developers have to explicitly check for data races after refactoring the code. Reported data races should be analyzed by developers to determine whether they are real or fake. To do that, developers must consider the application's workflow. Some methods in \framework{Android} are by design never called concurrently (.i.e \code{onCreateView} and \code{onDestroyView})~\cite{paperRetrofittingConcurrency}.

\subsection{Callback based $\rightarrow$ Method chained}
\textsc{Asyncifier} is a \framework{.NET} tool that automatically refactors callback-based asynchronous code into \code{async/await}. This tool has already been tested using real-world applications~\cite{paperAsyncMobile}.

Another tool in this category is \textsc{PromisesLand}. This tool converts \framework{JavaScript} asynchronous callbacks into \framework{Promises}. This refactoring facilitates code comprehension by replacing callbacks with chained calls~\cite{thesisJavaScript}. \textsc{PromisesLand} consist of a static analyzer and a transformation engine. The static analyzer is in charge of searching for asynchronous patterns that can be refactored into \framework{Promises}. The transformation engine is responsible for performing the refactoring~\cite{thesisJavaScript}.

In the last months, \textsc{RxFactor} was developed. As we mentioned before, this tool has some similarities with \toolcore{}. \textsc{RxFactor} takes the code from \code{AsyncTask}s and generates a functional implementation of that code using the \framework{ReactiveX} API. Although \textsc{RxFactor} and our tool have the same goal, and \code{AsyncTask}s are very similar to \code{SwingWorker}s, the refactoring approaches used are very different. We compare both approaches in Chapter~\ref{chapter:design}.

\subsection{Anti-patterns $\rightarrow$ Improvements}
\code{AsyncTask} should only be used for short-running operations (approx. less than a second). For long-running operations the class \code{IntentService} should be used ~\cite{paperStudyRefactoring}. This refactoring is also not trivial. According to a previous research, this might be due to the developer's lack of knowledge about how to use this class. The author of that study believes that the lack of knowledge is the consequence of not having enough production-level examples that use \code{IntentService}~\cite{paperStudyRefactoring}. \textsc{AsyncDroid} is a tool that can be used to convert \code{AsycnTask} into \code{IntentService}.

\textsc{AsyncFixer} is a \framework{.NET} tool that can be used to recognize performance anti-patterns of \java{async/await} in mobile applications (i.e. in \framework{Windows Phone}). This tool also suggests fixes. \textsc{AsyncFixer} has already been successfully tested using real-world applications~\cite{paperAsyncMobile}.

\chapter{Design of the System}
\label{chapter:design}

Previous studies show that functional and reactive programming models improve code writing and code comprehension~\cite{promises, paperReactiveComprehension}. In this thesis, we propose an approach to refactor \code{SwingWorker}s into \framework{RxJava}. This refactoring enables constructs that facilitate the implementation of the previously mentioned models. To minimize the effort required to perform the refactoring task, we developed a tool, \toolextension{}, that refactors \code{SwingWorker}s automatically. Once the automated refactoring has completed, one can use the constructs available in \framework{RxJava} to introduce reactive and functional programming concepts into the existing project.

This Chapter starts by presenting a practical example that shows how one can use \toolextension{} to refactor a real-world application and add new features to it using \framework{RxJava}. Then we explain the refactoring approach. Finally, we present the design of \toolcore{} and \toolextension{}.

\section{Use Case Example}

The next example illustrates how the refactoring works. The example bases on \framework{Juneiform} (Figure~\ref{fig:juneiform}), an application with OCR that extracts text from images.

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.95\textwidth]{juneiform/Juneiform.png}
\caption{Juneiform: \url{https://bitbucket.org/Stepuk/juneiform}\\\href{https://bitbucket.org/Stepuk/juneiform/src/c07e0bbcf17c2d63137f28109cf5812a231692de?at=default}{c07e0bbcf17c2d63137f28109cf5812a231692de}}
\label{fig:juneiform}
\end{center}
\end{figure}

In this example we focus on two classes, \code{DocumentLoader} and \code{Editor}. The \code{DocumentLoader} is the class in charge of importing the images into \framework{Juneiform}. Here we want to extend the functionality to add four observers to the event ``load document''. The \code{Editor} class is responsible for performing the OCR. Here we want to display a loading spinner and close it after the optical character recognition has completed. Furthermore, we want to automatically copy the output text to the clipboard.

\subsection{DocumentLoader}

The user can import images into Juneiform by clicking on the icon ``open Images'' \includegraphics[height=0.4cm]{juneiform/open-icon.png} (Figure~\ref{fig:loadDocs}). This action opens a file chooser dialog. After the user has selected the source images and clicked ``Open'', the application starts fetching the images. As soon as the fetching has completed, all images are displayed.

\begin{figure}[H]
\begin{center}
\includegraphics[height=6cm]{juneiform/DocumentLoader.png}
\caption{Load Documents in Juneiform}
\label{fig:loadDocs}
\end{center}
\end{figure}

The class responsible for loading the images into Juneiform is \code{DocumentLoader} (Listing~\ref{code:example-original-v1}). When the user selects the images from the file chooser dialog (Figure~\ref{fig:loadDocs}) and clicks ``Open'', the \code{load} (Listing~\ref{code:example-original-v1}:~Line~4) method of \code{DocumentLoader} is invoked using the previously selected files as argument. The files are then cached into a private field called \code{files}~(Listing~\ref{code:example-original-v1}:~Line~7). After that, \code{execute} is invoked (Listing~\ref{code:example-original-v1}:~Line~8). Since \code{DocumentLoader} is a subclass of the async construct \code{SwingWorker}, the next invocation is \code{doInBackground} (Listing~\ref{code:example-original-v1}:~Line~11) which logic corresponds to the asynchronous operation. The asynchronous operation consists in iterating through all \code{files} (Listing~\ref{code:example-original-v1}:~Line~13) and adding them one by one to a list \code{result} of type \code{Document} (Listing~\ref{code:example-original-v1}:~Line~15). The type \code{Document} is implemented in Juneiform and holds relevant information about a file such as its name, absolute path, image, among others. When the algorithm has iterated through all \code{files}, then the list \code{result} contains the previously selected images. The asynchronous operation ends when the method \code{doInBackground} returns (Listing~\ref{code:example-original-v1}:~Line~24). After the asynchronous operation has completed, the \code{done} (Listing~\ref{code:example-original-v1}:~Line~27) method is invoked by the \code{SwingWorker}. Notice that \code{doInBackground} returns a list of type \code{Document}. The return value of \code{doInBackground} (in this example: \code{result}) can be accessed from the method \code{done} by using \code{get} (Listing~\ref{code:example-original-v1}:~Line~29). The method \code{get} is declared in the superclass of \code{DocumentLoader} (Appendix~\ref{swingworkerapi}). Since \code{get} can throw whether an \code{InterruptedException} or an \code{ExecutionException}, a \code{try-catch} block is needed. Finally, if no exceptions are thrown, the \code{fetchResult} method is called using the returned value of the asynchronous operation as the argument (all files). This method displays the selected images in the UI.

Before applying the automated refactoring, we manually refactored eight lines in the original implementation of \code{DocumentLoader} so that we can show the images in the UI as soon as they are available. The purpose of this refactoring is to show that our approach can handle dynamically generated items. These items are generated every time the method \code{publish} is invoked. Basically, we applied three changes:
\begin{enumerate}
	\item We changed the second parameter of the \code{SwingWorker} from \code{Void} (Listing~\ref{code:example-original-v1}:~Line~\ref{codeline:DocumentLoader-1a}) to \code{Document} (Listing~\ref{code:example-pre-processing}:~Line~\ref{codeline:DocumentLoader-1b}). The second parameter corresponds to the data type of the intermediate results. 
	\item We generated intermediate results by using \code{publish} (Listing~\ref{code:example-pre-processing}:~Line~\ref{codeline:DocumentLoader-2b}), instead of accumulating all \code{Document}s in a list (Listing~\ref{code:example-original-v1}:~Line~\ref{codeline:DocumentLoader-2a}). Every time this method is invoked, the \code{SwingWorker} starts the execution of the method \code{process} using the intermediate results as the arguments (Listing~\ref{code:example-pre-processing}:~Line~27). The methods \code{publish} and \code{process} are declared in the superclass of \code{DocumentLoader} (Appendix~\ref{swingworkerapi}).
	\item We implemented \code{process}. The logic of \code{process} is similar to the one in \code{done}. The only difference is that \code{process} receives a list \code{chunks} (Listing~\ref{code:example-original-v1}:~Line~27) of type \code{Document} (See the second parameter of \code{SwingWorker} in Listing~\ref{code:example-pre-processing}:~Line~\ref{codeline:DocumentLoader-1b}) which can directly be used in \code{fetchResult} to update the images displayed in the UI. Since \code{chunks} is a variable and \code{fetchResult} does not throw any exception, there is no \code{try-catch} block in the method \code{process}.
\end{enumerate}

\input{code-examples/preprocessing.tex}

After having manually refactored the class \code{DocumentLoader}, as showed in Listing~\ref{code:example-pre-processing}, we used \toolextension{} to refactor Juneiform. Listings~\ref{code:example-original} and~\ref{code:example-refactored} show the source code of \code{DocumentLoader} before and after refactoring. The differences in both code snippets are highlighted. Notice that the code snippet presented in Listings~\ref{code:example-original} is an abstraction of the one showed in Listings~\ref{code:example-pre-processing}.

As showed in Figure~\ref{fig:swingWorker-execution}, the code contained in a \code{SwingWorker} can be executed whether on a background or on the UI thread. Everything that is called from \code{doInBackground} is executed in the background. The rest, methods \code{process} and \code{done}, is executed in the UI thread. In Juneiform, the background operation consists of reading the selected \code{File}s and converting them into \code{Document}s that can be manipulated by the application. The method \code{process} displays the \code{Document}s in the UI. Our refactoring separates this logic into two objects. The \code{Observable} (Listing~\ref{code:example-refactored}:~Lines~11-21) is responsible for the asynchronous operation (\code{doInBackground}) (Listing~\ref{code:example-refactored}:~Line~15), while the \code{Subscriber} (See Listing~\ref{code:example-refactored}:~Line~2) handles the synchronous ones (\code{process} and/or \code{done}). Our refactoring does not change the implementation contained in any of these three methods. Instead, these methods are wrapped in a \code{rx.Observable} or a \code{rx.Subscriber}, which are later use for introducing functional and reactive programming concepts into the existing application. The complete refactoring approach is explained in Section~\ref{sec:2rx-approach}. For now, the relevant part of the code is the \code{publish} invocation (Listing~\ref{code:example-refactored}:~Line~18) because this is the one responsible for generating the items of the \code{Observable} that can be manipulated using \framework{RxJava} functional programming constructs. The logic in charge of processing these items is in the method \code{process} (Listing~\ref{code:example-refactored}:~Line~23).

\input{code-examples/example-original-vs-refactored.tex}

\subsubsection{Functional and Reactive Programming in \code{DocumentLoader}}

So far, we have shown how our tool can refactor a \code{SwingWorker} into a \code{rx.Observable} and a \code{rx.Subscriber}. This refactoring enables \framework{RxJava} constructs that facilitate introducing functional and reactive programming concepts in Juneiform. 

Listings~\ref{code:example-edited} shows an example where we change the functionality of \code{DocumentLoader} in a functional fashion. In the new implementation, we add a filter to select only the images which format is jpg. Additionally, we change the display name of the image within Juneiform to uppercase and remove the extension of the file from the name. On the other hand, we implement a reactive model by using four \code{Subscriber}s. The code snippet showed in Listing~\ref{code:example-edited} works as follows:

\begin{itemize}
	\item {\bf Line 10}: we specify the thread in which the \code{Observable} operates. The scheduler \code{Schedulers.computation} corresponds to a background thread.
	\item {\bf Line 11}: the \code{publish} invocation uses the type \code{List<Document>}. Since it is more comfortable to work directly with \code{Document}s, rather than a list of this type, we use \code{flapMap} to extract the \code{Document} objects from the lists received from \code{publish}.
	\item {\bf Line 12}: at this point we have a stream of \code{Document}s. We filter these \code{Document}s to consider only jpg files.
	\item {\bf Line 13 - 17}: we transform the items by changing their display name to uppercase and simultaneously removing the file extension from them. In functional programming using state should be avoid~\cite{bookFunctionalProgramming}, therefore, we generate a new instance for each \code{Document} rather than changing the name directly in the current instance. 
	\item {\bf Line 18}: we specify that the operations that follow must be executed in the UI thread.
	\item {\bf Line 21 - 24}: we register a \code{Subscriber} using lambda notation that updates the UI and prints the name of the file. Listing~\ref{code:example-console} shows the console output. One can see that the \code{Subscriber} 0 prints the following text to the console for each file: \code{ Updating UI: <FileName>}
	\item {\bf Line 25 - 27}: we register further \code{Subscriber}s using lambda notation as well. Each of these \code{Subscriber}s prints the name of the file to the console. Listing~\ref{code:example-console} shows the console output for \code{Subscriber}s 1 to 3. Notice that the \code{Subscriber}s could perform more complex operations. We used the method \code{print} (Listing~\ref{code:example-edited}~Line:~34) to keep the example simple.
	\item {\bf Line 29}: we connect the \code{ConnectableObservable} to start the emissions.
\end{itemize}

\input{code-examples/example-manually-refactored.tex}

\input{code-examples/example-console-output.tex}

\newpage
\subsection{Editor}

Similarly, \toolextension{} refactored the class \code{Editor}. Listing~\ref{code:example-editor-original} shows the original source code. Here, there is a \code{SwingWorker} which is responsible for performing the optical character recognition in the background (Listings~\ref{code:example-editor-original}:~Line~7) and updating the user interface by executing some code in the UI thread (Listings~\ref{code:example-editor-original}:~Line~12). The specific implementations for these two actions are not relevant for this example. When the user clicks on the icon ``Perform OCR'' \includegraphics[height=0.4cm]{juneiform/ocr-icon.png} (Figure~\ref{fig:juneiform}), the method containing the code snippet from Listings~\ref{code:example-editor-original} gets executed. As soon as \code{execute} is reached (Listings~\ref{code:example-editor-original}:~Line~15), the \code{SwingWorker} execution starts as described in Figure~\ref{fig:swingWorker-execution}. 

\input{code-examples/example-editor-before-after.tex}

Listing~\ref{code:example-editor-refactored} shows the refactored code of the class \code{Editor}. The logic contained in the methods \code{doInBackground} (Listing~\ref{code:example-editor-refactored}:~Line~6) and \code{done} (Listing~\ref{code:example-editor-refactored}:~Line~14) did not change. However, the structure of the code did change. Now we have an \code{Observable} (Listing~\ref{code:example-editor-refactored}:~Lines~2-8) containing the asynchronous operation (\code{doInBackground}) and a \code{Subscriber} (Listing~\ref{code:example-editor-refactored}:~Lines~10-16) responsible for the synchronous one (\code{done}). In this case, the \code{Observable} starts the emissions as soon as the \code{executeObservable} invocation is reached (Listing~\ref{code:example-editor-refactored}:~Line~17). The complete refactoring approach is explained in Section~\ref{sec:2rx-approach}. For now, we only focus on the fact, that we have a \code{rx.Observable} (Listing~\ref{code:example-editor-refactored}:~Lines~2-8) that allows us to add features in a functional fashion.

\input{code-examples/example-editor.tex}

After performing the refactoring, we modify the source code manually to add new features. In this case, we implement a \code{Utils} class for showing and closing a loading spinner. Additionally, we add a method to copy the result of the OCR to the clipboard. The implementation details of the \code{Util} class and the \code{copyToClipboard} method are not relevant for this example. The important aspect here is that we can add features to the \code{Observable} using a functional notation, as showed in Listing~\ref{code:example-editor} (Lines 6-8). We declare the new features as follows:
\begin{itemize}
	\item {\bf Line 6:} we show a loading spinner when the observable is subscribed.
	\item {\bf Line 7:} the last emission corresponds to the result. We copy the result to the clipboard.
	\item {\bf Line 8:} we hide the loading spinner.
\end{itemize}

\section{Refactoring Approach}
As we mentioned before \textsc{RxFactor} and \toolextension{} refactor similar asynchronous constructs. However, there are some differences regarding the refactoring approach. In this section, we explain the refactoring approach used in \toolextension{}. After that, we present a summary of the refactoring approach proposed by \textsc{RxFactor} and explain why we decided to use a different one.

\subsection{\toolextension{} Approach}
\label{sec:2rx-approach}
There were three important aspects that we considered while developing the refactoring approach:
\begin{enumerate}
	\item Generate emissions on each \code{publish} invocation rather than only on the result, so that we can add several \code{Subscriber}s to an \code{Observable} without modifying it. The \code{Subscriber}s are then reactive to each emission of the \code{Observable}.
	\item All methods available in the \code{SwingWorker} API must be available in the \code{Subscriber}
	\item The \code{Observable} must stop sending items to the \code{Subscriber} if the second one has not finished processing the last emission.
\end{enumerate}

In order to fulfill these requirements, we extended RxJava. In this section, we explain the Extension in a very high level. The details follow in Chapter~\ref{sec:rxjava-extension}. 

The RxJava Extension is based on three classes: \code{SWEmitter}, \code{SWPackage} and \code{SWSubscriber}. 
\begin{itemize}
	\item The \code{SWEmitter} produces an emission on each \code{publish} and one at the end containing the async result.
	\item The \code{SWSubscriber} is responsible for processing the emissions. This class implements the methods available in the \code{SwingWorker} API and holds the state of the operation.
	\item The \code{SWPackage} is shared by the \code{SWEmitter} and the \code{SWSubscriber}. This structure allows us to send data from the \code{SWEmitter} to the \code{SWSubscriber}. This class uses a lock to avoid backpressure problems.
\end{itemize}

We base our refactoring on these three classes. Basically, we generate a \code{jar} file and add a dependency to this file in each project by updating the classpath. These classes can be modified post-refactoring, which is good for maintenance and improvements.

\subsubsection{SWPackage (Emission)}
The class that allows the communication between \code{SWEmitter} and \code{SWSubscriber} is called \code{SWPackage}. This structure contains dedicated fields for data chunks, which are sent on \code{publish}, the result, and a \code{ReentrantLock} that is used to stop the emissions from the \code{Observable} if the \code{Subscriber} is still processing the last one. See Section~\ref{sec:imp-package} for implementation details.

\subsubsection{SWEmitter}
The class responsible for generating the sequence is called \code{SWEmitter}. The \code{SWEmitter} starts by sending an initialization \code{SWPackage} to the \code{SWSubscriber}. Then the asynchronous operation starts. Inside of this operation, the method \code{publish} can be invoked multiple times. The invocation of \code{publish} generates an emission, which corresponds to a \code{SWPackage} that contains chunks of data. Finally, the \code{SWSubscriber} processes the emission. While it is being processed, the asynchronous operation responsible for generating emissions continues. However, if the \code{SWEmitter} reaches a \code{publish} invocation before the \code{SWSubscriber} finishes processing the last one, then the \code{SWEmitter} blocks, until the \code{SWSubscriber} is done. See Section~\ref{sec:imp-emitter}  for implementation details.

\subsubsection{SWSubscriber}
The class that manages all operations available in the \code{SwingWorker} API is called \code{SWSubscriber}. This class is reactive to the emissions generated by the \code{Observable} and contains all information about the state of the operation. The \code{SwingWorker} API holds three methods that directly influence the async operation. These methods are \code{execute}, \code{run} and \code{cancel}. Since after refactoring, these methods are called from the \code{SWSubscriber}, it might not be clear what these operations actually do. Therefore, we rename these methods to make them more clear. Table~\ref{table:origNamesVsNewNames} shows how we change the names after refactoring. All other method names remained the same. As we can see, the \code{SWSubscriber} must keep a reference to the \code{Observable} to be able to subscribe (execute or run) and cancel it. See Section~\ref{sec:imp-subscriber} for implementation details.

\begin{table}[H]
\footnotesize
\begin{center}
\begin{tabular}{|C{5cm}|C{5cm}|}
\hline
\bf SwingWorker Name & \bf SWSubscriber Name\\\hline
execute & executeObservable\\\hline
run & runObservable\\\hline
cancel & cancelObservable\\\hline
\end{tabular}
\end{center}
\caption{SwingWorker Method Names vs. SWSubscriber Method Names}
\label{table:origNamesVsNewNames}
\end{table}

\subsection{RxFactor Approach}
\textsc{RxFactor} is a tool that can refactor \code{AsyncTask}s into \framework{RxJava}. Listings~\ref{code:rxfactor-before} and~\ref{code:rxfactor-after} show an example of how this tool works. First an \code{Observable} is created by using \code{Observable.fromCallable} (Listing~\ref{code:rxfactor-after}:~Line~14). The argument of this method is a \code{Callable} object, which defines the asynchronous operation. Therefore the routine from \code{doInBackground} (Listing~\ref{code:rxfactor-before}:~Lines~5-7) is written here. 

The \code{publish} (Listing~\ref{code:rxfactor-before}:~Line~7) method cannot be copied inside of \code{fromCallable}, because this method is not defined in objects of type \code{Callable}. To be able to refactor \code{publish} invocations, a \code{Subscriber} is needed. This \code{Subscriber} is obtained from the method \code{getRxUpdateSubscriber} (Listing~\ref{code:rxfactor-after}:~Line 1), where \code{onNext} (Listing~\ref{code:rxfactor-after}:~Line 5) is implemented. As we can see, \code{Subscriber.onNext} and \code{onProgressUpdate} (Listing~\ref{code:rxfactor-before}:~Line 13) are equivalent. 

Since \code{fromCallable} returns a single result, \code{doOnNext} (Listing~\ref{code:rxfactor-after}:~Line~27) is used to read the only and therefore final emission of the observable, which corresponds to the result from \code{doInBackground}. The \code{AsyncTask} processes this result in \code{onPostExecute} (Listing~\ref{code:rxfactor-before}:~Line 19), which is why we find the same program code in \code{doOnNext}.


\input{code-examples/rxfactor-before-vs-after.tex}

This refactoring approach is able to transform \code{AsyncTask}s into \framework{RxJava}, as long as the methods \code{getStatus} and \code{isCancelled} are not invoked.  \textsc{RxFactor} cannot refactor these methods because it does not have a mechanism to keep track of the state of the asynchronous operation. In order to refactor these methods, it is necessary to know whether the asynchronous operation is Pending, Started, Done or Canceled. Neither flags nor methods are available in \framework{RxJava} for this purpose. A possible solution to this problem is to use a wrapper class. However, there is a drawback to this solution as well. The wrapper class would have to manage all method invocations of the \code{Subscriber} and the \code{Observable} in order to determine whether the status should be updated or not. If developers bypass the wrapper by for example subscribing an \code{Observable} directly, then the wrapper would not have any knowledge about his operation, and the status would remain unknown. Another alternative is to extend \framework{RxJava} to replicate the workflow of \code{AsyncTask}s. This is the solution that we used for \code{SwingWorker}s. We explain how this solution looks like in Section~\ref{sec:2rx-approach}.

According to the evaluation done in the research of \textsc{RxFactor}~\cite{thesisRxFactor}, the approach used by this tool is acceptable because the methods \code{getStatus} and \code{isCancelled} are not often used. However, that is not the case for \code{SwingWorker}s. Nine out of eighteen methods from the \code{SwingWorker} API require knowledge of the current state. In contrast to \code{AsyncTask}s, most \code{SwingWorker} instances use state related methods. This was the main reason for us to not use the approach of \textsc{RxFactor}.

There are also other drawbacks about the approach used in \textsc{RxFactor}. Since \code{Observable.fromCallable} is used, only one item is generated by the \code{Observable}. This item is the result of the asynchronous operation. If we connect the \code{Observable} to multiple \code{Subscriber}s, then these observers will only get the final result. Information about the data that was originally processed in the \code{AsyncTask} through \code{onProgressUpdate} will still depend on the \code{Subscriber} that is directly specified in the \code{Observable} (Listing~\ref{code:rxfactor-after}:~Line~21).

The current implementation of \textsc{RxFactor} can lead to out of memory exceptions. Listing~\ref{code:rxfactor-after} shows that the \code{Observable} creates an instance of \code{Subscriber<PublishT>} every time that Line 20 is reached. This line is responsible for generating items and send them to the \code{Subscriber} so that they are processed in the UI thread. If the \code{Observable} generates too many items and the \code{Subscriber}s require much time to process them, then there will be eventually too many instances of \code{Subscriber<PublishT>}. If the number of instances keeps increasing, then an out of memory exception will be thrown at some point. 

Rewriting the approach to have a single instance of \code{Subscriber<PublishT>} would solve the out of memory exception issue, but then backpressure problems could occur. Although \code{Observable.fromCallable} is backpressure friendly, the way that this construct is combined with the \code{Subscriber} (Line 20) would make the implementation vulnerable to backpressure problems. These problems occur when the \code{Observable} produces items faster than the capacity of the \code{Subscriber} to consume them. \framework{RxJava} takes care of this problem when the \code{Observable} and the \code{Subscriber} are linked by using the \code{subscribe} method. However, this is not the case in \textsc{RxFactor}. In Listing~\ref{code:rxfactor-after} one can see that the \code{Observable} has no knowledge about the \code{Subscriber}. If the \code{Callable} object used in \code{Observable.fromCallable} (Line 14) generates items too fast, then the buffer of the \code{Subscriber} will eventually be full. After that happens, the next items will be lost and therefore remain unprocessed. A possible solution to this problem is to use Java locks in the \code{Observable} and \code{Subscriber} in order to synchronize both objects and stop generating items in the \code{Observable}, in case that the \code{Subscriber} is busy and has no space in its buffer. 

Notice that out of memory and backpressure problems only occur under very specific circumstances. However, we consider important to be aware of these issues.

The last disadvantage that we found about the approach used in \textsc{RxFactor} is that two objects from \framework{RxJava} are needed to refactor the public method invocations from \code{AsyncTask}s. Table~\ref{table:asynctask-rx-methods} shows these objects. The first column of this table contains the public methods of the \code{AsyncTask} API. The column ``Rx Class'' corresponds to the \framework{RxJava} class that must be used to refactor the \code{AsyncTask} method, while the column ``Rx Equivalent Method'' shows the name of the method of the corresponding \framework{RxJava} class. As we already explained, \code{getStatus} and \code{isCancelled} cannot be refactored without a wrapper class or similar structure. Basically, most methods can be refactored using \code{rx.Observable}. However, if \code{cancel} is invoked, then one needs to generate a \code{Subscription} from the \code{Observable} and call \code{unsubscribe}.

\input{design/asynctask-rxjava-method-match.tex}

Listings~\ref{code:rxfactor-cancel-before} and ~\ref{code:rxfactor-cancel-after} show an example where refactoring the \code{cancel} invocation automatically is not trivial. In this example the \code{AsyncTask} is executed in a class and canceled in a different class when an event is triggered. Here we can see that a naive implementation of replacing \code{AsyncTask} objects by \code{rx.Observables} does not work, because the \code{Observable} does not posses the \code{unsubscribe} method. The \code{Subscription} is obtained when the \code{Observable is subscribed} (Listing~\ref{code:rxfactor-cancel-after}:~Line 6). This \code{Subscription} must be passed to the class \code{EventListener} so that it can be canceled. However, if \code{EventListener} does not use the \code{cancel} method from the \code{AsyncTask}, then it is not necessary to pass the reference to the \code{Subscription} to it. The fact of having to work with two objects to refactor all methods from \code{AsyncTask}s into \framework{RxJava} makes the static analysis and automated refactoring more complicated and error prone.

\input{code-examples/rxfactor-cancel.tex}

Due to these reasons, we decided to use a different approach to overcome these disadvantages.

\section{Tool Development}
We used the Plugin Development Environment (PDE) from Eclipse to implement a tool to perform automated refactoring of \code{SwingWorker}s into \framework{RxJava}. Since the concepts that we explain in this thesis are not Eclipse specific but can be used for implementing similar tools in other IDEs or even standalone versions, we do not dedicate a section to explain how PDE works. Instead, we focus on the architecture of our tool. For details about PDE, we recommend the official documentation~\cite{pdeEclipse} and the thesis of Ramachandra Kamath Arbettu (\textsc{RxFactor})~\cite{thesisRxFactor}.

The general requirements of the refactoring tool were:
\begin{enumerate}
	\item Target: \framework{Java} projects
	\item Single Run: refactor one or multiple projects in a single run
	\item Extendability: support extensions
\end{enumerate}

To fulfill these requirements, we developed two main projects. The first projects is \toolcore{} and the second one is \toolextension{}. \toolcore{} implements the common functionality to all extensions and defines the interface that must be implemented by them. The extensions contain the specific implementation for refactoring a particular construct. In this thesis, we present the implementation of \toolextension{}. One can use this implementation as a reference to create further extensions such as \textsc{ForLoop2Rx}, \textsc{WhileLoop2Rx}, \textsc{Runnable2Rx}, etc. Additionally, we developed a third project for test-driven development.

Figure~\ref{fig:plugin-design} shows a diagram representing the interaction between \toolcore{} and Extensions. \toolcore{} is in charge of iterating through all opened projects in the workspace. During this iteration, the \framework{Java} projects are filtered. The next step is to iterate through all \framework{Java} projects. Then, we update the classpath of the target project. Each extension must contain at least one \code{jar} file in its resources directory (rxjava-x.y.z.jar). We did not add this \code{jar} file to \toolcore{} to allow extensions decide which \framework{RxJava} version should be used.

Next, \toolcore{} gets a collector instance from the extension. A collector is a class that contains all relevant AST nodes for performing the refactoring. After that, \toolcore{} iterates through the compilation units in the project and calls a method from the extension to process each of them. Processing a unit consist of a static analysis of the code and adding relevant AST nodes to the collector.

After processing all the units, \toolcore{} proceeds to refactor the code using the collector. To be able to refactor the original code, refactoring workers are necessary. These workers are implemented in the extension. \toolcore{} uses the class \code{Processor} to invoke the workers concurrently, execute the changes and update a results map. The results map is a map that matches the original compilation unit to the refactored code, saved as a string. This map is only required for testing purposes, where the changes are not written to the files, but read from the map to use them for the assertions.

\toolcore{} also manages confirmation, error, progress and termination dialogs.

\begin{figure}[h]
\begin{center}
\includegraphics[width=15cm]{design/plugin-design.png}
\end{center}
\caption{Plugin Design}
\label{fig:plugin-design}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[width=14cm]{design/tool-ui.png}
\end{center}
\caption{\toolcore{} and \toolextension{}}
\label{fig:tool-ui}
\end{figure}

Figure~\ref{fig:tool-ui} shows what developers see when the plugin is installed. To run the tool, the developer must go to the menu ``2Rx'' and then select the target refactoring action. This action prompts a confirmation dialog. After clicking ``Ok'' the refactoring starts. While the projects are being refactored, a progress dialog is shown for each project. When the refactoring of a project has completed, the changes are shown in the console. Finally, an information dialog is shown saying that all projects have been refactored.

Currently \toolcore{} does not support either interrupting the operation nor ``UNDO''. Developers should have a backup of their files before starting the operation.

\subsection{\toolcore{} Components}
\label{sec:core-components}
\toolcore{} consists of six main components:
\begin{enumerate}
	\item Action handler: it identifies which extension triggered the refactoring operation and starts the process.
	\item Abstract collector: each client must implement a collector because the relevant information for the refactoring task depends on the specific case. In order to benefit from polymorphism, we defined an abstract collector in \toolcore{}. Collectors in clients must extend this class. Workers use the collector to perform the refactoring task. Since clients can only use one collector instance, all necessary information must be collected in the same object.
	\item Abstract worker: workers are the objects that transform the code, based on the collected AST nodes. Each worker is responsible for a specific case. Workers are also implemented in clients by extending the class \code{AbstractWorker} of \toolcore{}. It usually makes sense to have multiple workers with clear responsibilities. Workers use a single unit writer to specify the transformations in a single \framework{Java} file. The refactored compilation units must be registered in a multiple unit writer.
	\item Processor: the processor is implemented in \toolcore{} and it is in charge of executing the workers and updating the target files by using the multiple unit writer.
	\item Single unit writer: \toolcore{} contains a default implementation of this writer. This class can be extended by clients in order to support further refactoring functions. Since multiple workers could access the same single writer simultaneously, this class must be thread-safe.
	\item Multiple unit writer: collects the compilation units that have changed. This class contains a method to update the target files. After this method has been executed, the refactoring operation has completed.
\end{enumerate}

\toolcore{} also provides its clients with utility classes and a code generator. The utility classes offer a variety of methods to query information about AST nodes, perform code transformations directly in the AST, send log messages to the console, validate source code strings, among others. The code generator corresponds to a class that contains methods to create several AST node types from source code. The supported AST nodes are single statements, blocks of statements, method declarations, type declarations and field declarations. Defining these AST nodes with JDT (Eclipse Java Development Tools) in the conventional way usually requires a lot of code because every node of the target syntax tree must be specified. Generating these AST nodes from text facilitates the implementation and maintenance.

\subsection{Extension Setup}
\toolcore{} provides an extension point that allows adding clients to the plugin without modifying the existing code. In this extension point we specified that clients must implement the interface \code{RxJavaRefactoringExtension} (Listing~\ref{code:extension-interface}).

\input{code-examples/extension-interface.tex}

Additionally, we created a template project facilitate the implementation of extensions. This project contains a \code{README} file that explains how to setup the template. The template contains a default package structure. The action handler in the extension is already implemented. This handler is in charge of forwarding the action event to \toolcore{}. \toolcore{} reads the command id from the event to identify which extension triggered operation. There is also a default implementation of the \code{RxJavaRefactoringExtension} interface. This file contains placeholders in string values that must be replaced and TODOs in methods that must be implemented.

\chapter{Implementation of the System}
\label{chapter:implementation}
The refactoring approach used by \toolextension{} is based on the implementation of three classes that complement \framework{RxJava}. In this chapter, we explain how these classes work. Furthermore, we present some refactoring examples for different AST nodes (input vs. output). After that, we focus on the implementation of \toolextension{} and finally we talk about the template projects available that can be used to implement and test extensions.

\section{RxJava Extension}
\label{sec:rxjava-extension}
We developed an extension to support the \code{SwingWorker} API in \framework{RxJava}. The purpose of this extension is to refactor \code{SwingWorker}s into \framework{RxJava} considering the observer pattern. To accomplish that, we separate the target \code{SwingWorker} into a subject and an observer. The subject is responsible for executing the asynchronous operation (\code{doInBackground} method) while the observer is in charge of processing the intermediate results (\code{process} method) and the final result (\code{done} method) in the main thread. Intermediate results are generated on each \code{publish} invocation, while the final result corresponds to the return value of the method \code{doInBackground}. In general terms, the goal of the refactoring is to have a subject capable of generating the intermediate and final results and an observer to process them. Subjects and observers can also be called observables and subscribers respectively.

\subsection{Class Diagram}

Figure~\ref{fig:umlrxjava-extension} shows an UML Class Diagram of the \framework{RxJava} extension for \code{SwingWorker}s. The package \code{rx} contains classes from \framework{RxJava} while the package \code{de.tudarmstadt.stg.rx.swingworker} contains the classes that we implemented. In the rest of this section, we explain the interaction between the classes showed in the UML Class Diagram. The \framework{RxJava} classes are \code{Observable}, \code{Emitter}, \code{Observer}, \code{Subscriber}, \code{Action1}, and the ones implemented by us are \code{SWEmitter}, \code{SWPackage}, \code{SWSubscriber}, \code{RxSwingWorkerAPI}. It is recommended to look at the Class Diagram while reading to facilitate comprehension.

There are several ways of creating observables in \framework{RxJava}. One of them is using the class \code{Observable} which offers different methods to create an \code{Observable} instance. One can use the method \code{Observable.fromEmitter} to implement algorithms that define when to generate items. In order to create an \code{Observable} using this method, one needs an \code{Action1} of type \code{Emitter}. The \code{Action1} interface has only a void method with one argument. The \code{Emitter} is an interface that extends \code{Observer}.

\input{code-examples/emitter-example.tex}

Listings~\ref{code:emitter-example} shows how to create an \code{Observable} using the method \code{fromEmitter} and how the \code{Emitter} and the \code{Subscriber} interact with each other. The algorithm responsible for generating the items is implemented in the \code{call} method of \code{Action1} (Listings~\ref{code:emitter-example}:~Line~1). The item generation is done using the class \code{Emitter} (Listing~\ref{code:emitter-example}:~Lines~2~to~11). On the other hand, the \code{Subscriber} contains the logic to process the generated items (Listings~\ref{code:emitter-example}:~Lines~12~to~21).

The algorithm consists of a \code{for}-loop (Listings~\ref{code:emitter-example}:~Line~4). On each iteration the method \code{Emitter.onNext(i)} is called (Listings~\ref{code:emitter-example}:~Line~5). This method generates an item with the integer value \code{i} which is processed by the \code{Subscriber} (Listings~\ref{code:emitter-example}:~Line~13). After nine iterations, the method \code{Emitter.onCompleted} is invoked (Listings~\ref{code:emitter-example}:~Line~7) which triggers the \code{onCompleted} method from the \code{Subscriber} (Listings~\ref{code:emitter-example}:~Line~19). If there are any exceptions during the execution, then the \code{Emitter.onError(e)} method is invoked (Listings~\ref{code:emitter-example}:~Line~9). This error is handled in the \code{Subscriber} as well (Listings~\ref{code:emitter-example}:~Line~16). Listings~\ref{code:emitter-example-output} shows the console output produced by Listings~\ref{code:emitter-example}. Summarizing, the \code{Action1} implements an algorithm that specifies when items should be generated (\code{onNext}), when the operation has completed (\code{onCompleted}) and when to handle an exception (\code{onError}). This signals are received and processed by the \code{Subscriber}.

Due to the following reasons, the example showed in Listing~\ref{code:emitter-example} cannot be used as it is to replicate the behavior of \code{SwingWorker}s: 
\begin{enumerate}
	\item \code{SwingWorker}s allow using a data type for the final result and a different one for intermediate results. \code{Emitter}s, on the contrary, only allow using a single data type.
	\item \code{SwingWorker}s have state flags that are not available neither in \code{Subscriber}s nor in \code{Observable}s. \code{Subscriber}s have only one state related method called \code{isUnsubscribed}. Other state queries available in \code{SwingWorker}s such as \code{getState}, which return \code{PENDING}, \code{STARTED} or \code{DONE}, or queries such as \code{isCancelled}, \code{isDone}, \code{getProgress} have no equivalent in \code{Subscriber}s. The following methods: \code{addPropertyChangeListener}, \code{removePropertyChangeListener}, \code{firePropertyChange} and \code{getPropertyChange}, are also not available in \code{Subscriber}s. These last four methods require the object \code{PropertyChangeSupport} in order to be implemented.
\end{enumerate}

In order to tackle the first problem, we implemented \code{SWPackage}, a generic data structure that accepts two parameters. The first parameter \code{R} is for the result of the asynchronous operation and the second parameter \code{P} is for the intermediate results. Listing~\ref{code:emitter-two-types-example} shows how one can create an \code{Observable} based on an \code{Emitter} of type \code{SWPackage}. In this example, we set the parameters \code{R} and \code{P} of the \code{SWPackage} to be \code{Integer} and \code{String} respectively. The code snippet showed in Listing~\ref{code:emitter-two-types-example} works as follows:
\begin{itemize}
	\item {\bf Line 1}: We create the \code{Observable} from an \code{Emitter} of type \code{SWPackage<Integer,String>>}.
	\item {\bf Lines 4-17}: We define the algorithm to generate the items. The algorithm consists of iterating from zero to ten and sending a \code{String} to the \code{Subscriber} on each iteration. The indexes \code{i} used for the iteration are accumulated in the variable \code{accum} and returned at the end of the operation as \code{Integer}.
	\begin{itemize}
		\item {\bf Line 7}: We create the \code{SWPackage} instance that is used to generate the next item in the current iteration.
		\item {\bf Line 8}: We create the \code{String} value for the next item based on the iteration index \code{i}.
		\item {\bf Line 9}: We add the intermediate result \code{text} to the \code{SWPackage} by using the method \code{setChunks}. This method accepts multiple arguments of type \code{String} and returns a \code{SWPackage}. After that, we invoke the \code{onNext} method of the \code{emitter} using the \code{SWPackage} as argument to finally generate the item.
		\item {\bf Line 10}: We update the \code{accum} variable.
		\item {\bf Line 12}: Once the iterations has completed, we create another \code{SWPackage} to generate the item that contains the final result.
		\item {\bf Line 13}: Similar to Line 9, we put the result of the operation into the \code{SWPackage}. This time, we use \code{setResult} which accepts a single argument of type \code{Integer} and returns a \code{SWPackage} as well. The final result item is then generated by calling \code{onNext} on the \code{emitter} using the \code{SWPackage}.
		\item {\bf Lines 14-17}: Same as in Listing~\ref{code:emitter-example}
		\end{itemize}
	\item {\bf Lines 20-34}: We implemented the methods of the \code{Subscriber} responsible for handling the events \code{onNext}, \code{onCompleted}, \code{onError}.
		\begin{itemize}
			\item {\bf Lines 23}: We retrieve the intermediate results from the \code{item} using \code{getChunks}.
			\item {\bf Lines 24-27}: If there are intermediate results, we take the first one and print it to the console. Notice that this value corresponds to a \code{String}.
			\item {\bf Line 28}: We retrieve the final result from the \code{item} using \code{getResult}.
			\item {\bf Lines 29-31}: If there is a result, then we print it to the console. Notice that the data type of this value is \code{Integer}.
			\item {\bf Line 33}: Commented out. Same implementation as in Listing~\ref{code:emitter-example}
		\end{itemize}
\end{itemize}

\input{design/umlrxjava-extension.tex}

\input{code-examples/emitter-two-types.tex}

In order to tackle the second problem, we extended the class \code{Subscriber} from \framework{RxJava}. The extension of this class, \code{SWSubscriber}, consists of adding fields that allow us to implement the missing methods. One of these fields is \code{currentState}. The value of this field is returned when the method \code{SWSubscriber.getState()} is invoked. Before the asynchronous operation starts, the value of the field is \code{PENDING}. We overrode the method \code{onStart} so that the field \code{currentState} is changed to \code{STARTED} as soon as the method is invoked (Listing~\ref{code:swsubscriber-onstart}). The method \code{onStart} is triggered when the \code{SWSubscribed} is subscribed. Additionally, we also overrode the method \code{onCompleted} to make this field change to \code{DONE} (Listing~\ref{code:swsubscriber-oncompleted}). Similarly we used the rest of the fields to replicate the state related behavior of \code{SwingWorker}s using RxJava.

The classes \code{SWPackage} and \code{SWSubscriber} are enough to refactor \code{SwingWorker}s into \framework{RxJava}. With \code{SWPackage} we can define different data types for intermediate and final results. \code{SWSubscriber} implements all methods of the \code{SwingWorker} API. The refactoring can be done manually in 15 steps:
\begin{enumerate}
	\item Copy the \code{doInBackground} implementation of the \code{SwingWorker} into the \code{call} method of \code{Action1}.
	\item Identify all \code{publish} invocations
	\item Create a \code{SWPackage} for each \code{publish} invocation
	\item Use the method \code{setChunks} from \code{SWPackage} and use the arguments specified in \code{publish}
	\item Generate the item by using \code{Emitter.onNext(SWPackage pkg)}
	\item Identify all \code{setProgress} invocations
	\item Create a \code{SWPackage} for each \code{setProgress} invocation
	\item Use the method \code{setProgress} from \code{SWPackage} and use the same progress as argument
	\item Repeat step 5
	\item Identify the \code{return} statements
	\item Create a \code{SWPackage} for each \code{return} statement
	\item Use the method \code{setResult} from \code{SWPackage} and use the \code{return} value as argument
	\item Repeat step 5
	\item At the end of the \code{call} method, add \code{Emitter.onCompleted} to signal that the asynchronous operation has completed.
	\item Finally, surround everything with a \code{try-catch} block and use \code{Emitter.onError} in the catch clause to trigger the \code{onError} method of the \code{SWSubscriber} in case that an exception is thrown
\end{enumerate}

One can see that this refactoring is not trivial. Even though the refactoring can be performed automatically, developers might have trouble understanding the output code if they are not familiar with \framework{RxJava}. Notice that we only need to consider two methods (\code{publish} and \code{setProgress}) and the return value for the refactoring. The rest of the algorithm remains the same, regardless of the implementation of \code{doInBackground}. In order to hide this abstraction from developers and make the refactoring easier and more comprehensible, we implemented \code{SWEmitter} and \code{SWSubscriber} using the template method pattern. 

In the class \code{SWEmitter}, we specify that the method \code{doInBackground} must be implemented by the subclass. The methods \code{publish} and \code{setProgress} of the \code{SWEmitter} take care of the steps 2 to 9 that were mentioned above. Similarly, in the class \code{SWSubscriber}, we specify that the methods \code{process} and \code{done} must be implemented by the subclass. By doing this, developers need not to reason about \code{Emitter}s, \code{onNext}, \code{onCompleted}, \code{onError} and \code{SWPackage}. See Sections~\ref{sec:imp-seq-diagram},~\ref{sec:imp-package},~\ref{sec:imp-emitter}~and~\ref{sec:imp-subscriber} for more details about the implementation of these three classes.

\subsection{Sequence Diagram}
\label{sec:imp-seq-diagram}

Figure~\ref{fig:rxjava-extension} shows the interactions between \code{SWEmitter}, \code{SWPackage} and \code{SWSubscriber}. In general, the \code{SWEmitter} produces items of type \code{SWPackage}. Then, \framework{RxJava} internally sends these items to the \code{SWSubscriber}. In the diagram, we use the term ``Emissions Pool'' to represent this interaction. For the explanation, we can assume that the \code{SWEmitter} places the items into a pool and the \code{SWSubcriber} takes them from there.

\begin{figure}[h]
\begin{center}
\includegraphics[width=15.5cm]{design/rxjava-extension.png}
\end{center}
\caption{RxJava Extension for SwingWorkers}
\label{fig:rxjava-extension}
\end{figure}

The class \code{SWPackage} has two functions. The first one is to support items of different data types and the second one is manage the synchronization between \code{SWEmitter} and \code{SWSubscriber} in order to avoid backpressure problems. 

The asynchronous operation starts by initializing a \code{lock} in the \code{SWEmitter}. This \code{lock} is used for all \code{SWPackage}s. Then an initialization \code{SWPackage} is created and sent to the emissions pool. After that, the asynchronous operation starts (\code{doInBackground}). While this operation is running, the methods \code{publish} or \code{setProgress} can be invoked multiple times. This invocations also generate \code{SWPackage}s that are pushed into the emissions pool, where they are taken and processed from the \code{SWSubscriber}. If the emission was generated by a \code{publish} invocation then the \code{process} method of the \code{SWSubscriber} will be invoked. When the asynchronous operations finishes, a final \code{SWPackage} containing the result is sent to the emissions pool again. Finally, the \code{onCompleted} method of the \code{SWSubscriber} is invoked. This method triggers the piece of code contained in the \code{done} method of the \code{SWSubscriber}.

While the \code{SWPackage}s are being processed, the \code{SWSubscriber} updates the state of the operation (\code{PENDING}, \code{STARTED}, \code{DONE}). The \code{SWSubscriber} contains all methods available in the \code{SwingWorker} API including the state relevant ones.

\subsection{Package Data Structure}
\label{sec:imp-package}
The main purpose of the \code{SWPackage} is to manage synchronization and encapsulate different types of data. Listings~\ref{code:swpackage-contain} how these fields are defined in the generic class. The progress is defined as an \code{AtomicInteger} to make the variable thread-safe. The other two types can only be accessed through getters and setters that use locks to guarantee thread-safe access. The \code{processingLock} is shared among all \code{SWPackage}s. This object comes from the \code{SWEmitter} and is the one that allows us to avoid backpressure problems.

\input{code-examples/swpackage-contain.tex}

\subsection{Emitter}
\label{sec:imp-emitter}
The \code{SWEmitter} generates the \code{SWPackage}s that are going to be processed by the \code{SWSubscriber}. Listings~\ref{code:swemitter-regular-emissions} shows the implementation of the standard emissions in a \code{SWEmitter}. We call them standards because they are always produced. There are two emissions of this kind, initialization (Listing~\ref{code:swemitter-regular-emissions}:~Line~3) and result (Listing~\ref{code:swemitter-regular-emissions}:~Line~5). Notice that \code{setResult} returns an \code{SWPackage} as well, otherwise, it would not be possible to use this call as a parameter for \code{onNext} (Listing~\ref{code:swemitter-regular-emissions}:~Line~4).

\input{code-examples/swemitter-regular-emissions.tex}

The \code{doInBackground} method is abstract and must therefore be implemented in the subclass. This implementation can invoke the \code{publish} (Listing~\ref{code:swemitter-dynamic-emissions}:~Line~11) and/or the \code{setProgress} (Listing~\ref{code:swemitter-dynamic-emissions}:~Line~15) method multiple times. If these methods are invoked, then they are forwarded to the \code{SWSubscriber} using a \code{SWPackage} as well. Listings~\ref{code:swemitter-dynamic-emissions} (Lines 12, 16) shows how the forwarding was implemented. Notice that \code{setChunks} and \code{setProgress} return an \code{SWPackage} as well.

\input{code-examples/swemitter-dynamic-emissions.tex}

\subsection{Subscriber}
\label{sec:imp-subscriber}
The \code{SWSubscriber} is the class responsible for managing state related operations that are available in the \code{SwingWorker}. In order to manage stateful operations, it is necessary to have private fields that can be updated on specific events. For example: The state of the \code{SwingWorker} depends on the field \code{currentState}. At the beginning of the asynchronous operation, this field has the value \code{PENDING}. When the operation starts, the method \code{onStart} from the \code{SWSubscriber} is invoked, making the status change to \code{STARTED} (Listing~\ref{code:swsubscriber-onstart}:~Line~4). We use the \code{countDownLatch} to be able to wait for the asynchronous result when the \code{get} method is invoked(Listing~\ref{code:swsubscriber-onstart}:~Line~3). This is necessary because the \code{SwingWorker} API specifies that \code{get} is blocking.

\input{code-examples/swsubscriber-onstart.tex}

Listing~\ref{code:swsubscriber-onnext} shows how the \code{SWSubscriber} processes the \code{SWPackage}. First, it updates the async result. If no result is present, then the value remains \code{null} (Listing~\ref{code:swsubscriber-onnext}~Line~3). Then it checks whether a progress value was sent and if so, it updates the \code{progress} field (Listing~\ref{code:swsubscriber-onnext}~Lines~4-5). Finally, if the \code{publish} method in the \code{SWEmitter} was invoked, the data is taken and processed in the \code{process} method (Listing~\ref{code:swsubscriber-onnext}~Lines~7-8).

Listings~\ref{code:swsubscriber-oncompleted} shows the termination of emissions. At the end, the \code{onCompleted} method of the \code{SWSubscriber} is invoked. Here the \code{countDownLatch} is decrease by one to report that the asynchronous operation has finished (Listings~\ref{code:swsubscriber-oncompleted}:~Line~2). Then the \code{done} method of the \code{SWSubscriber} is invoked (Listings~\ref{code:swsubscriber-oncompleted}:~Line~3) and finally the state is set to \code{DONE} (Listings~\ref{code:swsubscriber-oncompleted}:~Line~4).

\input{code-examples/swsubscriber-onnext-oncompleted.tex}

The \code{SWSubscriber} implements all methods available in the \code{SwingWorker} API. Explaining how they are implemented would require copying the source code of the whole class in this section. Therefore we have limited ourselves to explain the \framework{RxJava} related methods.


\section{Refactoring Approach}
\label{sec:refactoring-approach}
In this thesis, we propose a refactoring approach that allows transforming \code{SwingWorker}s to \framework{RxJava} by modifying a few lines of the source code. This is possible because the \code{SwingWorker} workflow is imitated through the interaction between \code{SWEmitter}, \code{SWPackage} and \code{SWSubscriber}.

In the following subsections, we explain how we refactore different AST nodes. These code snippets can be compared to the example showed at the beginning of Chapter~\ref{chapter:design}, to understand how the transformations in the Juneiform application were performed (Listings~\ref{code:example-original},~\ref{code:example-refactored}).

On the left side we present the original source code and on the right side the refactored one.

\subsection{Assignments}
\label{sec:imp-assigments}
The usage of the AST node \code{Assignment} involves working with variables. We observed that often the variable names contain the substrings ``swingWorker'' or     ``worker''. Since we are refactoring this construct, we replace these substrings by ``rxObserver''.

\input{refactorings/assignment.tex}

There are also cases where a variable can be directly assigned to a class instance creation. The refactoring of class instance creations is shown in subsection~\ref{sec:imp-class-instance-creations}.

\subsection{Variable Declaration Statements}
\label{sec:imp-variableDeclStatement}
Similar to \code{Assignment}s, \code{SingleVariableDeclaration}s involve variable names that must be adjusted. Additionally, the data type \code{SwingWorker} must be changed to \code{SWSubscriber} (Listings~\ref{code:vds-before} and ~\ref{code:vds-after}).

\input{refactorings/variable-decl-statement.tex}

It is also possible to have \code{ClassInstanceCreation}s in \code{VariableDeclarationStatements} AST nodes. See subsection~\ref{sec:imp-class-instance-creations} for more details about the refactoring of \code{ClassInstanceCretion} nodes.

\subsection{Class Instance Creations}
\label{sec:imp-class-instance-creations}
\code{ClassInstanceCreation}s are the AST nodes that actually contain the implementation of the \code{SwingWorker}. During the refactoring, we separate this implementation into two objects. The \code{Observable} and the \code{SWSubscriber}. The \code{Observable} contains the logic for the asynchronous operation, while the \code{SWSubscriber} has the logic responsible for processing both types of results, intermediate and final. The \code{SWEmitter} and the \code{SWSubscriber} were designed to support the protected methods of the \code{SwingWorker} API. Therefore the blocks \code{doInBackground}, \code{process} and \code{done} do not need to be modified (Listings~\ref{code:cic-before} and~\ref{code:cic-after}).

\input{refactorings/class-instance-creation.tex}

\subsection{Field Declarations}
\label{sec:imp-fieldDeclaration}
\code{FieldDeclaration}s are very similar to \code{VariableDeclarationStatement}s. Normally, it is only necessary to adjust the variable name and change the data type from \code{SwingWorker} to \code{SWSubscriber}. However, we do have an important special case for \code{FieldDeclaration}s. Our approach creates two objects out of a \code{SwingWorker} and the constructor of the \code{SWSubscriber} requires an \code{Observable}. To make the code more readable, we decided to create an inner class that extends \code{SWSubscriber} and generate the \code{Observable} there (Listings~\ref{code:fd-before} and~\ref{code:fd-after}).

\input{refactorings/field-decl.tex}

Another alternative for refactoring this kind of \code{FieldDeclaration}s is to write the \code{Observable} directly in the constructor (See Listing~\ref{code:fd-alternative}), but in our opinion, this code is harder to read, specially if the method \code{doInBackground} has many lines.

\input{refactorings/field-decl-special-case.tex}

\code{SwingWorker}s can also contain custom fields and/or methods. In these cases, we also use an inner class such as \code{RxObserver}, showed in Listing~\ref{code:fd-after}, that contains all of the custom fields and methods. By doing that we guarantee, that the pieces of code contained in the \code{Observable} and the \code{SWSubscriber} still have access to those elements.

\subsection{Method Declaration}
\label{sec:imp-methodDecl}
We also modify \code{MethodDeclaration}s to adjust the return value from \code{SwingWorker} to \code{SWSubscriber} (Listings~\ref{code:md-before} and~\ref{code:md-after}).

\input{refactorings/method-declaration.tex}

\subsection{Method Invocations}
\label{sec:imp-methodInvocation}
Only three methods out of eighteen were renamed in the \code{SWSubscriber}. The refactoring of \code{MethodInvocation} nodes also involves checking the name of the invokers and adjusting them if necessary. The substrings ``swingWorker'' and ``worker'' are replaced by ``rxObserver''. Listings~\ref{code:mi-before} and~\ref{code:mi-after} shows the refactoring of the only methods that were renamed.

\input{refactorings/method-invocations.tex}

\subsection{Simple Names}
\label{sec:imp-simpleName}
We refactor \code{SimpleName}s to adjust the argument name of \code{SwingWorker} types in invocations (Listings~\ref{code:sn-before} and~\ref{code:sn-after}).

\input{refactorings/simplename.tex}

\subsection{Single Variable Declarations}
\label{sec:imp-singleVarDeclaration}
\code{SwingWorker}s can also be parameters of methods. The variables defined in a \code{MethodDeclaration} are called \code{SingleVariableDeclaration}. We use this AST node to refactor refactor these \code{SwingWorker}s into \code{SWSubscriber}s (Listings~\ref{code:svd-before} and~\ref{code:svd-after}).

\input{refactorings/single-variable-decl.tex}

\subsection{Type Declarations}
\label{sec:imp-typeDecl}
In order to refactor \code{TypeDeclaration} nodes, it is necessary to change the superclass of the target node from \code{SwingWorker} to \code{SWSubscriber}. Furthermore, we need to set the \code{Observable} in the constructor. Listings~\ref{code:td-before} and~\ref{code:td-after} illustrate how this is done. Notice that the method \code{getRxObservable} is the same that we use for the special case of \code{FieldDeclaration}s (Listing~\ref{code:fd-after}).

\input{refactorings/type-decl.tex}

\section{\toolcore{} and \toolextension{}}
\toolcore{} and \toolextension{} work together to perform the automated refactoring of \code{SwingWorker}s to \framework{RxJava}. The first step to implement an extension of \toolcore{} is to define its id, name and the location of its resources (i.e. required jar files). After that, the object responsible for collecting all relevant AST nodes for the refactoring must be implemented. To refactor \code{SwingWorker}s it is necessary to collect the following AST nodes: \code{TypeDeclaration}, \code{FieldDeclarations}, \code{Assignment}, \code{VariableDeclarationStatement}, \code{SimpleName}, \code{ClassIntanceCreation}, \code{SingleVariableDeclaration}, \code{MethodInvocation} and \code{Me}- \code{thodDeclaration}.


\subsection{Collectors}
The collector has a \code{Map} for each of these fields. The \code{Map} holds compilation units and a list of the corresponding node. Listing~\ref{code:collector} shows an example of the fields that we use for the collector of \toolextension{}.

\input{code-examples/collectors.tex}

\subsection{Processing}
At the beginning the collector is empty. The collector is updated on each \code{processUnit} invocation (Figure~\ref{fig:plugin-design}). Since the collector only holds the nodes, another object is needed to analyze the current unit. For that purpose, we use a class that extends \code{ASTVisitor}. The visitor iterates through all nodes of the compilation units and adds the relevant nodes to a list containing the corresponding node type. There are as many \code{List}s in the visitor as \code{Map}s in the collector.

The difference between the visitor and the collector is that a new visitor instance is used for each compilation unit, meaning that a visitor only contains the relevant information for a single compilation unit, while the collector contains all the relevant nodes for the whole project. Listing~\ref{code:processing} shows how the visitor and the collector interact with each other.

\input{code-examples/process-unit.tex}

\subsection{Workers}
When all compilation units have been processed, then \toolcore{} uses the collector and a set of workers provided by the extension (See Figure~\ref{fig:plugin-design}) to perform the refactorings. In order to have workers with clear responsibilities and avoid long classes, we implemented a worker for each \code{ASTNode} present in the collector. That makes a total of nine workers.

Listing~\ref{code:workers-pseudo-code} presents the refactoring algorithm used. First, we get the corresponding map from the collector. For each entry in this map, we take the key, which corresponds to a compilation unit. Then, we iterate trough the values of each map entry. The values correspond to the target nodes. In each of these nodes, we run a refactoring visitor that performs a static analysis and caches all relevant information. Then we apply the refactorings using the abstract syntax tree, the compilation unit, the visitor, the single unit writer and the target node. Finally, we register the current compilation unit into the multiple units writer.

The single unit writer does not modify either the compilation units nor the abstract syntax trees. Instead, it registers the changes in a \code{ASTRewrite} object. By doing this we guarantee, that all workers have access to the original code. After all workers have been executed, the multiple units writer applies the changes to the compilation units.

\input{code-examples/workers-pseudo.tex}

After we have implemented all workers, we add them to a set, which is used by \toolcore{} to refactor the original code. Listing~\ref{code:workers} shows how we build the set of workers.

\input{code-examples/workers-set.tex}

\subsection{Writers}
It is possible to extend the \code{RxSingleUnitWriter}, explained in Section~\ref{sec:core-components}, to support transformations that might not have been considered in \toolcore{}. Since all workers are executed simultaneously it is important to make sure that the methods here implemented are thread-safe. To accomplish that, we use the construct \code{synchronized}. Listing~\ref{code:rxsingleunitwriter-threadsafe} shows an example for replacing a \code{SimpleType}.

\input{code-examples/writer-example.tex}

\subsection{Source Code Generation}
\toolcore{} provides a couple of methods that can be used to generate code from a string (source code). By using these methods and \framework{FreeMarker}~\cite{freeMarker} templates, we generate source code without having to specify all nodes using JDT. Listing~\ref{code:subscriber-ftl} shows the template used for generating inner class \code{RxSubscriber} showed in Listing~\ref{code:cic-after}. Basically, there is a \framework{Java} object called \code{model} that contains all necessary information for filling up the templates. This object is passed to the \framework{FreeMarker} processor in order to produce the source code.

\input{code-examples/subscriber-ftl.tex}

\subsection{Test-Driven Development}
\label{sec:test-driven-dev}
We also developed a third project for test-driven development. This project only contains tests. The main idea is to have a basic project containing the cases to be tested. Each file contains a single case (Figure~\ref{fig:unit-test-results}). Additionally, there is a second folder containing all expected \framework{Java} classes, which are used for the assertions.

When the tests are executed, the basic project is refactored without writing the changes to the files. In this way, we guarantee that the input files never change and can always be reused. The resulting code of each compilation unit is saved in a map. For the comparison, we generate an AST for output and expected file. Then the trees are compared. The purpose of doing this is to ignore irrelevant differences such as spaces, empty lines, comments, etc.

Similar to the extensions, there is a template to facilitate setting up the project for the unit tests. This template contains abstract tests classes that can be used to load \framework{Android} or \framework{Java} projects, create \framework{Java} projects and assert source code based on string values.

\begin{figure}[H]
\begin{center}
\includegraphics[height=5cm]{unit-tests/unit-tests-results1.png}
\includegraphics[height=5cm]{unit-tests/unit-tests-results2.png}
\end{center}
\caption{Unit Test Results}
\label{fig:unit-test-results}
\end{figure}

\section{Templates}
We developed two templates, to facilitate developing and testing extensions for \toolcore{}.

Figure~\ref{fig:template-ext} shows the package structure of the template design for extensions. The template consists of five classes. The \code{Handler} is already implemented. Its function is to forward the event to \toolcore{}. The classes \code{Extension}, \code{ExtCollector} and \code{FirstWorker} contains ``TODOs'' to facilitate their implementation. The name ``FirstWorker'' is a placeholder and should be renamed by developers to improve comprehension. The \code{SwingleUnitWriter} from \toolcore{} can directly be used by extensions. However, since the probability of having to add a method to this class is high, we added the \code{SingleUnitExtensionWriter} to the template, where new methods for manipulating the source code can be added.

Similarly, Figure~\ref{fig:template-test} shows the package structure of the template design for writing unit tests. This template consists of four abstract classes and three example tests classes. In order to be able to test \toolcore{} and its extensions, it is necessary to have an Eclipse project. These abstract classes open or create a project containing the input files. By using this templates developers can skip those steps and start writing the assertions they need. In Listing~\ref{code:unit-test-example} we show how a test would look like. The method \code{executeTest} is already implemented in the template project.

\begin{figure}[h]
\begin{subfigure}{0.5\textwidth}
\begin{center}
\includegraphics[width=5.5cm]{templates/extension.png}
\end{center}
\caption{Extension Template}
\label{fig:template-ext}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\begin{center}
\includegraphics[width=5.5cm]{templates/tests.png}
\end{center}
\caption{Test Template}
\label{fig:template-test}
\end{subfigure}
\caption{Template Projects}
\end{figure}

\input{code-examples/unit-test.tex}

\chapter{Evaluation}
\label{chapter:evaluation}
We divided the evaluation into two parts. The first one corresponds to the accuracy of the refactoring approach and the second one focuses on the extensibility of the \toolcore{}.

\section{Refactoring Approach}
We used 58 projects for the evaluation of the refactoring approach:
\begin{itemize}
	\item 1 project for unit tests (Section~\ref{sec:eval-unit-test})
	\item 10 projects for UI tests (Section~\ref{sec:eval-ui-test})
	\item 47 projects to analyze the original code versus the refactored one. The analysis consist of code inspections and making sure that there are no compilation errors after refactoring. (Section~\ref{sec:eval-src-analysis})
\end{itemize}

\subsection{Dataset for Unit Tests}
\label{sec:eval-unit-test}
In the implementation phase, we developed a project for unit tests following the test-driven development technique (Section~\ref{sec:test-driven-dev}). The test cases in this project were designed considering \code{SwingWorker} relevant \code{ASTNode}s. In order to identify these nodes, we used the AST view from Eclipse. The AST view is an Eclipse plugin that allows one to determine which \code{ASTNode} type corresponds to a particular construct in the source code. Figure~\ref{fig:ast-view} shows the ASTView panel on the left side and Editor on the right. If the option ``Link with Editor'' \includegraphics[height=0.35cm]{unit-tests/link-to-editor.png} is enabled, then any selection on the ASTView panel will move the cursor in the Editor (source code) to the corresponding \code{ASTNode}. Similarly, any selection in the Editor highlights the corresponding node in the ASTView panel. In this example, the cursor in the Editor points to \code{new}~\code{SwingWorker} and therefore the node \code{ClassInstanceCreation} is highlighted in the ASTView.

\begin{figure}[H]
\begin{center}
\includegraphics[width=17cm]{unit-tests/ASTView-vs-SrcCode.png}
\end{center}
\caption{AST View}
\label{fig:ast-view}
\end{figure}

In order to design the test cases, we went through the source code of several projects and used the ASTView panel to identify the \code{ASTNode}s that are involved with \code{SwingWorker}s. During this inspection we found 9 \code{ASTNode}s. We show an example of each of these nodes in Section~\ref{sec:refactoring-approach}:
\begin{itemize}
	\item Section~\ref{sec:imp-assigments}: \code{Assignment}
	\item Section~\ref{sec:imp-variableDeclStatement}: \code{VariableDeclarationStatement}
	\item Section~\ref{sec:imp-class-instance-creations}: \code{ClassInstanceCreation}
	\item Section~\ref{sec:imp-fieldDeclaration}: \code{FieldDeclaration}
	\item Section~\ref{sec:imp-methodDecl}: \code{MethodDeclaration}
	\item Section~\ref{sec:imp-methodInvocation}: \code{MethodInvocation}
	\item Section~\ref{sec:imp-simpleName}: \code{SimpleName}
	\item Section~\ref{sec:imp-singleVarDeclaration}: \code{SingleVariableDeclaration}
	\item Section~\ref{sec:imp-typeDecl}: \code{TypeDeclaration}
\end{itemize}

We then proceeded to design test cases for each of these \code{ASTNode}s.

\subsection{Dataset for UI Tests}
\label{sec:eval-ui-test}
We chose the projects for UI tests from Bitbucket according to the following criteria: small projects (less than 50 \framework{Java} files) that compile without having to setup a server, database, etc. We did not select these projects randomly because our goal was to be able to evaluate them at runtime and make sure that the behavior of the applications did not change. Randomly chosen applications are often not compilable due to missing files, complex setups, etc.

\subsection{Dataset for Source Code Analysis}
\label{sec:eval-src-analysis}
We used the remaining 47 projects to evaluate the refactoring tool by analyzing its output. We downloaded these projects randomly from Github. The search was performed using the Search site from Github ``\url{https://github.com/search}''. We used the following search parameters, Query: ``\code{SwingWorker}'', Language: \framework{Java}, Sort: Recently indexed. The equivalent search URL is: 
\begin{itemize}
	\item {\footnotesize \url{https://github.com/search?l=Java&o=desc&q=SwingWorker&ref=searchresults&s=indexed&type=Code&utf8=\%E2\%9C\%93}}
\end{itemize}

We did not consider further search parameters such as the number of stars or forks because the number of projects found was too small. Table~\ref{table:results-starts-forks} shows an overview of the search results when using starts and/or forks as search parameters.

\begin{table}[h]
{\footnotesize
\begin{center}
\begin{tabular}{|p{5cm}|C{3cm}|}
\hline
\bf Criteria & \bf Nr. Results\\\hline
Stars $>$ 0 and Forks > 0 & 0\\
Stars $>$ 0 & 4\\
Forks $>$ 0 & 3\\
Stars $>$ 0 or Forks > 0 & 7\\
\hline
\end{tabular}
\end{center}
}
\caption{Search Results using Nr. of Starts and Forks}
\label{table:results-starts-forks}
\end{table}

From the list of results, we downloaded the first 50 Eclipse or Maven projects. Then we imported them into the Eclipse workspace to make sure that they compile. We analyzed projects that did not compile in order to determined whether the noncompilable source code was \code{SwingWorker} relevant or not. If the noncompilable code was not \code{SwingWorker} relevant, then we commented it out to hide the compilation errors showed in the IDE. Commenting out few lines of code does not affect the integrity of the evaluation because these projects were not meant to be tested at runtime. Three out of the fifty projects could not be properly setup to avoid compilation errors before refactoring. Therefore, we removed these projects from the final lists of projects to be evaluated.

\subsection{Results}
Once we finished the implementation of \toolextension{}, including the unit tests, we proceeded to test the tool using 58 projects. Approximately 10\% of the projects (6/58) presented errors. We analyzed these errors, identified the missing test cases and added them to the unit tests. Table~\ref{table:results} shows an overview of the final results. The 58 projects contain over 10,000 Java files. From these files, \toolextension{} refactored 180 files and a total of 678 \code{ASTNode}s. 676 \code{ASTNode}s were refactored successfully, while 2 \code{ASTNode}s presented errors. In Section~\ref{sec:eval-limitations} we show the limitations of \toolextension{}. On the right side of Table~\ref{table:results} we show which kind of AST nodes containing \code{SwingWorker} were refactored. Appendix~\ref{appendix:eval-details} shows the results of each project.

\begin{table}[H]
{\footnotesize
\begin{center}
\begin{tabular}{|p{5cm}|C{2cm}|}
\hline
& \bf Total \\\hline
Projects & 58\\
Java Files & 10,055\\
Refactored Java Files & 180\\
Refactored ASTNodes & 678\\
Refactored ASTNodes (Successful) & 676\\
Refactored ASTNodes (Failed) & 2\\
Time & 5 min 17 s\\
\hline
\end{tabular}\hspace{1cm}
\begin{tabular}{|p{5cm}|C{2cm}|}
\hline
ASTNode & \bf Total\\\hline
TypeDeclaration & 78\\
FieldDeclaration & 42\\
Assignment & 41\\
VariableDeclarationStatement & 70\\
SimpleName & 116\\
ClassInstanceCreation & 146\\
SingleVariableDeclaration & 9\\
MethodInvocation & 171\\
MethodDeclaration & 5\\
\hline\hline
\bf Total & \bf 678\\
\hline
\end{tabular}
\end{center}
}
\caption{Refactoring Results}
\label{table:results}
\end{table}

We performed a runtime evaluation and code inspections. We used 10 projects for the runtime evaluation (Appendix~\ref{appendix:eval-details} - Projects 2-11). This evaluation consisted of running the applications before and after refactoring and making sure that the behavior of the program did not change. For the code inspections, we used 48 projects (Appendix~\ref{appendix:eval-details} - Projects 1, 12-58). In this case, we randomly took about 10\% of the refactored \code{ASTNode}s and verified that the output corresponds to the expected source code. We computed the 10\% based on the total number of refactored \code{ASTNode}s in each project, which can be read from the Eclipse console.

The results presented above show that the refactoring approach presented in this thesis and the tool \toolextension{} are accurate. Approximately 99,7\% of the \code{SwingWorker} relevant \code{ASTNode}s were refactored successfully.

\subsubsection{Limitations}
\label{sec:eval-limitations}

The limitations of \toolextension{} are not linked to the refactoring approach, but to the implementation of the tool. Listings~\ref{code:limitation-original} and~\ref{code:limitation-refactored} show the refactoring of a \code{SwingWorker} instance creation. From the developer's point of view, the refactoring consists of changing one line (Listing~\ref{code:limitation-original}: Line~1 by Listing~\ref{code:limitation-refactored}: Line~1) and adding three new lines (Listing~\ref{code:limitation-refactored}: Lines~2,7,9). However, what \toolextension{} actually does is to read the whole \code{SwingWorker} as showed in Listing~\ref{code:limitation-original}, and use that source code to generate the complete code showed in Listing~\ref{code:limitation-refactored}. This implementation makes impossible to refactore nested \code{SwingWorker}s because only the outer \code{SwingWorker} is considered. In order to support refactoring nested \code{SwingWorker}s, the implementation of \toolextension{} have to be modified, so that the tool only refactors the lines highlighted in Listing~\ref{code:limitation-refactored}. This way, the tool would also be able to refactor the code inside \code{doInBackground}, \code{process}, \code{done} and any other method inside of a \code{SwingWorker}.

\input{code-examples/limitation-intro.tex}

Listing~\ref{code:nested-swingworkers} shows an example of nested \code{SwingWorker}s. Originally an \code{ExecutorService} submits the instance \code{singleRun} by invoking \code{executorSC.submit(singleRun)}. The variable \code{singleRun} is an instance of \code{SCWRLrunner}, which is a subclass of \code{SwingWorker}. In order to fix this compilation error manually, one must replace the error line by ``\java{singleRun.executeObservable()}''. Notice that the manual fix is not necessary if \toolextension{} is modified as described above.

\input{code-examples/nested-swingworkers.tex}

Another limitation found during the evaluation of the projects was method names clashes. Not all method names that can be used in \code{SwingWorker} subclasses, can also be used in \code{rx.Subscriber} subclasses. Listing~\ref{code:method-name-conflict} shows an example of this problem. Since \code{SwingWorker}s do not have any method matching the name ``\code{add}'', the original code compiles. However the new subclass of \code{rx.Subscriber} does have an ``\code{add}'' method and therefore, the code does not compile. 

The solution is to replace Line 6 (Listing~\ref{code:method-name-conflict}) by ``\java{AsyncPanel.this.add(targetComponent,}~\java{BorderLayout.CENTER);}'' because \code{AsyncPanel} is the name of the class containing the target method. One could implement an analyzer to check the validity of method names while performing the refactoring. In case that conflicts are found, then one could change the method invocation to \code{<ClassName>.this.<MethodName>(<arguments>)}.

Due to time limitations we did not adjust \toolextension{} to support nested \code{SwingWorker}s, neither to avoid method clashes.

\input{code-examples/method-name-conflict.tex}

\section{Extensibility of \toolcore{}}
In order to evaluate the extensibility of \toolcore{}, we refactored the implementation of \textsc{RxFactor} to make it a client of \toolcore{}. We call this extension \toolrxfactor{}. This refactoring did not require applying any changes in \toolcore{}.

\subsection{Experimental Setup}
We evaluated the extensibility of \toolcore{} using 34 projects. These projects were taken from \url{https://github.com/vogellacompany/codeexamples-android/tree/ae69e4c9a89b577659185381eef7dce206afc2cd}, a public repository in Github that contains 257 Android projects. We downloaded all projects and selected the ones that use \code{AsyncTask}s.

The validation consists of performing the automated refactoring of the 34 projects using \textsc{RxFactor} and \toolrxfactor{} and comparing the outputs of both tools.

\subsection{Validation Approach}
To validate that \toolrxfactor{} and \textsc{RxFactor} produce the same exact result, we refactored the \framework{Android} projects two times. The first time using \textsc{RxFactor} and the second time using \toolrxfactor{}. We placed the output from both tools in different directories and ran the following Linux command to compare the directories, their files, and the contents of each file:

\begin{textcode}{}
diff -r RxFactor/ AsyncTask2Rx/ -x *.classpath -x *.project -x *.jar -x *.class -x *.cache -x gen
\end{textcode}

The argument \code{r} is used to specify that the command must be executed recursively (includes all subdirectories). The arguments \code{RxFactor} and \code{AsyncTask2Rx} correspond to the directories where we saved the outputs locally. Finally, in order to compare only \framework{Java} files, we used the argument \code{x} to exclude the files with extensions \code{classpath}, \code{project}, \code{jar}, \code{class} and \code{cache}. Additionally we also excluded the directory \code{gen}. The files contained in this directory are automatically generated when the project is built.

\subsection{Results}
The refactoring was applied to 24 \code{ASTNode}s. The ``diff'' operation found a difference in both folders (Listing~\ref{code:eval-diff}). However, one can see that there are no semantic changes in the source code. Due to this result, we inspected both files and found that they differ because of the position of the method \code{getRxUpdateSubscriber}. While \textsc{RxFactor} places the method \code{getRxUpdateSubscriber} in Line 54, \toolcore{} places it in Line 24. When we refactored \textsc{RxFactor}, we used several methods from a class of \toolcore{} called \code{RxSingleUnitWriter}. Specifically, we used the method \code{addMethod} for inserting \code{getRxUpdateSubscriber} into the source code. \textsc{RxFactor} has a similar method for this purpose. Listings~\ref{code:2rx-addMethod} and~\ref{code:rxFactor-addMethod} show the implementation of \code{addMethod} in \textsc{RxFactor} and \toolcore{} respectively. In both code snippets, one can see that Line 3 defines the position of the method to be inserted. \textsc{RxFactor} uses \code{insertLast} and \toolcore{} uses \code{insertFirst}. Therefore, the Java files obtained after refactoring the class \code{AsyncLoadingActivity} with both tools (See Listing~\ref{code:eval-diff}) are not equal. However, they are semantic equivalent.

These results show that the \textsc{RxFactor} was successfully adapted into an extension of \toolcore{}.

\input{code-examples/eval-diff.tex}

\input{code-examples/save-addMethod.tex}

\chapter{Conclusion}
\label{chapter:conclusion}
Modern programming languages are making use of event-driven programming models and reactivity to facilitate both code writing and code comprehension, specially when developing asynchronous applications.

Asynchrony can improve the responsiveness of applications. Since refactoring asynchronous code is not trivial, researchers have developed tools to perform this task. Each tool targets a specific language and problem:

\begin{itemize}
	\item \textsc{PromisesLand} (JavaScript): converts asynchronous callbacks into \code{Promises}.
	\item \textsc{Asyncifer} (C\#): refactors callback-based asynchronous code into \code{async/wait} constructs
	\item \textsc{AsyncFixer} (C\#): finds anti-patterns of \code{async/wait} and suggest fixes
	\item \textsc{Asynchronizer} (Android): converts synchronous code into \code{AsyncTask}
	\item \textsc{AsyncDroid} (Android): converts \code{AsyncTask} into \code{IntentService}
	\item \textsc{RxFactor} (Android): converts \code{AsyncTask}s into \framework{RxJava}.
\end{itemize}

Previous studies have shown that these tools are needed, highly applicable and accurate~\cite{paperAsyncMobile, paperStudyRefactoring, thesisJavaScript}.

Furthermore, other studies agree that functional and reactive programming models improve code writing and code comprehension~\cite{promises, paperReactiveComprehension}. In this thesis, we show how to automatically refactor \code{SwingWorker}s into \framework{RxJava} in order to facilitate introducing reactive programming concepts in \framework{Java} applications that use this async construct. The results show that the developed tool is reliable. From 678 AST nodes (declarations, instances, invocations, methods, variables, fields, among others) that contained \code{SwingWorker}s, \toolextension{} successfully refactored 676, which represents approximately 99.7\%.

\section{Future Work}

Since the plugin was divided into core (\toolcore{}) and extension (\toolextension{}), it is possible to use \toolcore{} in future research to develop further extensions. The core could also be refactored to improve the user experience, adding settings and/or a help section, and implementing a ``UNDO'' feature would be some examples of where to start.

\subsection{Further Async Constructs}
In this thesis, we focused on refactoring \code{SwingWorker}s. There are also other async constructs that can be refactored to \framework{RxJava}. As showed in Listing~\ref{code:con-runnable-before}, fire and forget operations are usually implemented using the standard \framework{Java} classes \code{Runnable} and \code{Thread}. This construct can be refactored to \framework{RxJava} in order to facilitate modifying the behavior of the program using functional programming (Listing~\ref{code:con-runnable-after}). Notice that the method \code{performOpAsync} changed from being a \code{void} method (Listing~\ref{code:con-runnable-before}:~Line~11) to return an object of type \code{Void} (Listing~\ref{code:con-runnable-after}:~Line~11). This change is mandatory because an object is needed for the method \code{fromCallable} (Listing~\ref{code:con-runnable-after}:~Line~3).

\input{code-examples/con-runnables.tex}

Since \code{Runnable}s are fire and forget, they do not return any value. Assuming that we modify the method \code{performOpAsync} after refactoring, so that it returns a list, then it is possible to use \framework{RxJava} methods to filter~(Listing~\ref{code:con-enabled-methods-runnable}:~Line~5) and transform (Listing~\ref{code:con-enabled-methods-runnable}:~Line~5) the items of the list. Additionally, we could execute an operation based on each of these items (Listing~\ref{code:con-enabled-methods-runnable}:~Line~7). Furthermore, the \code{Observable} object can be used to create reactive programming models in the existing code (See Listing~\ref{code:rxJava-reactive-code}).

\input{code-examples/con-enabled-methods-runnable.tex}

\code{Callable}s can also be used in \framework{Java} for implementing asynchronous operations. Listing~\ref{code:callable-before} presents an example where a \code{Callable} is used to perform the operation \code{computeResult} (Listing~\ref{code:callable-before}:~Line~1). In contrast to \code{Runnable}s, \code{Callable}s does return a result. This result can be obtained by using the reference to the corresponding \code{Future} (Listing~\ref{code:callable-before}:~Line~4). Listing~\ref{code:callable-after} shows how the original code can be refactored to \code{RxJava}. In this case the \code{Callable} can be directly used in the \code{fromCallable} method (Listing~\ref{code:callable-after}:~Line~1). The result of the asynchronous operation can be accessed through \code{doOnNext} (Listing~\ref{code:callable-after}:~Line~4).

\input{code-examples/con-callables.tex}

\subsection{Java 8 and Functional Programming}
\framework{Java 8} introduces a series of classes to work with data streams. However, \framework{Java 8} does not offer methods to specify in which thread an operation should be performed. Refactoring these constructs to \framework{RxJava} would facilitate introducing asynchrony in functional models implemented in \framework{Java 8}. 

Listing~\ref{code:con-java8} shows how data streams can be manipulated in \framework{Java 8}. First, we filter the products from store \code{STORE_A} which price is greater than 50 (Listing~\ref{code:con-java8}:~Lines~2-4). Then, we create new products based on the filtered items by incrementing the price on 10\% (Listing~\ref{code:con-java8}:~Lines~5-7). These products are assigned to the store \code{STORE_B} (Listing~\ref{code:con-java8}:~Line~8). Finally, we save the new products using a data access object (Listing~\ref{code:con-java8}:~Line~9).

Listing~\ref{code:con-rxjava} shows how the previous example looks after refactoring. Instead of creating a stream of data (Listing~\ref{code:con-java8}:~Line~1), it is necessary to create an \code{Observable} that contains the products (Listing~\ref{code:con-rxjava}:~Line~1). The functions \code{filter} and \code{map} are identical. Then, we need to specify the operation that should be perform on each item (Listing~\ref{code:con-rxjava}:~Line~9). Since \code{doOnNext} only declares the function, it is necessary to subscribe the \code{Observable} in order to actually perform the operation (Listing~\ref{code:con-rxjava}:~Line~10).


\input{code-examples/con-java8-rxjava.tex}

Listing~\ref{code:con-enabled-methods-java8} shows some of the methods that were enabled thanks to this refactoring:
\begin{itemize}
	\item {\bf Line 9} (\code{subscribeOn}): to specify in which thread the operations should be executed (i.e.~a background thread)
	\item {\bf Line 11} (\code{doOnError}): to handle errors that might occur while processing the items
	\item {\bf Line 12} (\code{observeOn}): to specify in which thread the following operations should be executed (i.e.~main thread)
	\item {\bf Line 13} (\code{doOnCompleted}): to execute an action after the data processing has completed (i.e.~updating the UI)
\end{itemize}

\input{code-examples/con-enabled-methods-java8.tex}

\subsection{RxJava Extension}
We developed an \framework{RxJava} extension targeting \code{SwingWorkers}. We suggest that future research considers analyzing this extension to evaluate the potential of improvement. One of the improvements involves refactoring the communication between the emitter \code{SWEmitter} and the subscriber \code{SWSubscriber} in order to avoid blocking the \code{publish} method of the \code{Observable} when the \code{SWSubscriber} is processing the previous \code{SWPackage}. A possible solution would be to implement a buffer and block only when the buffer is full.

\bibliographystyle{plain}
\nocite{*}
\bibliography{ifill-brito-bsc-thesis}


\def\appendixstart{\chapter{Appendix} \section{SwingWorker API}\label{swingworkerapi}}
\includepdf[pages={1}, scale=0.90, pagecommand={\appendixstart}]{swingworker-api/SwingWorkerAPI-writer.pdf}
\includepdf[pages={2-3}, scale=0.90, pagecommand={}]{swingworker-api/SwingWorkerAPI-writer.pdf}

\section{Evaluation Projects}
\subsection{Projects}
The following table contains a list of the projects used for the evaluation. The first project was developed by us for unit-test purposes. Projects 2 to 11 were chosen from Bitbucket, in order to perform UI tests. These projects were not selected randomly. The rest of the projects were selected randomly from Github.
\label{appendix:eval-projects}
\input{evaluation/projects.tex}

\newpage
\subsection{Results}
\subsubsection{Overview}
The following table contains an overview of the results. The column changes corresponds to the sum of all refactored AST nodes in each project.
\label{appendix:eval-results-overview}
\input{evaluation/overview.tex}

\newpage
\subsubsection{Refactored ASTNodes}
The following table contains the information about the specific AST nodes that were refactored in each project.
\label{appendix:eval-details}
\input{evaluation/details.tex}


\end{document}