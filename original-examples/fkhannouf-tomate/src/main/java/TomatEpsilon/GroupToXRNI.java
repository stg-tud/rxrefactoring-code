package TomatEpsilon;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.Vector;
import java.io.*;
import java.util.AbstractCollection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.jdom.*;
import org.jdom.output.*;

/*
 * GroupToXRNI.java
 *
 * Created on 27 déc. 2009, 23:22:08
 */

/**
 *
 * @author fkhannouf
 */
public class GroupToXRNI extends JPanel implements ActionListener, ControlContext {



    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        directoryButton = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        startButton = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        directoryField = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        logTextArea = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        clearButton = new javax.swing.JButton();

        setBackground(new java.awt.Color(0, 255, 51));
        setDoubleBuffered(false);
        setEnabled(false);
        setFocusable(false);
        setOpaque(false);

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 3, 18));
        jLabel1.setText("Group samples into Renoise instruments");

        jLabel2.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel2.setText("Step 1");

        directoryButton.setText("Choose");
        directoryButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                directoryButtonActionPerformed(evt);
            }
        });

        jLabel3.setText("a directory containing samples.");

        jLabel6.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel6.setText("Step 2");

        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        jLabel7.setText("bulk processing of audio files in");

        directoryField.setEditable(false);
        directoryField.setFocusable(false);

        jLabel8.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel8.setText("Step 3");

        jLabel9.setText("Check if everything is all right in the log, and you're done :-)");

        logTextArea.setColumns(20);
        logTextArea.setEditable(false);
        logTextArea.setRows(5);
        jScrollPane1.setViewportView(logTextArea);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setText("Samples will be grouped into the same XRNI depending of their names.\n\nFor example : \nPiano  A1.wav, Piano B2.wav, Piano C4.wav ... will all belong to the Piano.XRNI file with correct keys mapping.");
        jTextArea1.setWrapStyleWord(true);
        jTextArea1.setAutoscrolls(false);
        jTextArea1.setBorder(null);
        jTextArea1.setFocusCycleRoot(true);
        jTextArea1.setMinimumSize(new java.awt.Dimension(550, 80));
        jTextArea1.setOpaque(false);
        jTextArea1.setRequestFocusEnabled(false);
        jTextArea1.setVerifyInputWhenFocusTarget(false);
        jScrollPane2.setViewportView(jTextArea1);
        jTextArea1.getAccessibleContext().setAccessibleParent(this);

        clearButton.setText("Clear log");
        clearButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 714, Short.MAX_VALUE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 714, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(startButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(directoryField, javax.swing.GroupLayout.DEFAULT_SIZE, 423, Short.MAX_VALUE))
                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(directoryButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3))
                    .addComponent(jLabel6, javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel8)
                            .addComponent(jLabel9))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 232, Short.MAX_VALUE)
                        .addComponent(clearButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(directoryButton)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(startButton)
                    .addComponent(jLabel7)
                    .addComponent(directoryField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel8)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel9))
                    .addComponent(clearButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 170, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    static private SwingWorker worker;
    static private final String[] notesArray={"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
    static private final String newline = "\n";
    static org.jdom.Document XMLDocument;

    /** Creates new form GroupToXRNI */
    public GroupToXRNI(){
        initComponents();

        // Instanciation of SwingWorker

    }

    private void directoryButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_directoryButtonActionPerformed
        try {
            File file;
            if(directoryField.getText().equals("")){
                file = new File(System.getProperty("user.home"));
            }else{
                file = new File(directoryField.getText());
            }

            JFileChooser fc = new JFileChooser(file);
            fc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
            if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
                String selectedDir = (fc.getSelectedFile().isDirectory()) ? (fc.getSelectedFile().getPath()) : (fc.getSelectedFile().getParent());
                
                directoryField.setText(selectedDir);

            }
        } catch (SecurityException ex) {
            Tomate.showInfoDialog();
            ex.printStackTrace();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
}//GEN-LAST:event_directoryButtonActionPerformed

    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        worker = new SwingWorker() {
            public void batch(){

                // Tableau associatif contenant toutes les familles d'instruments et les notes
                HashMap instruments = new HashMap();
                String workingDirAbsolutePath;
                Vector wavFileNames;
                Vector allNotesArray;
                Vector groupNameVector;
                File[] wavFiles;
                boolean success;

                workingDirAbsolutePath=directoryField.getText();

                File srcDirectory=new File(workingDirAbsolutePath);

                // Initialisation du tableau des notes
                allNotesArray=buildAllNotes(0,9);

                appendLog("Scanning: " + workingDirAbsolutePath + "" + newline);

                // Remplissage du vecteur avec les noms des fichiers
                wavFileNames=new Vector();
                wavFiles=srcDirectory.listFiles();
                for( File wavFile : wavFiles){
                    String waveFileName = wavFile.getName();
                    wavFileNames.add(waveFileName);
                    appendLog("Found : "+waveFileName+ newline);
                }

                // Parcours de tous les noms de fichiers trouvés
                for ( Object wavFileNameObj : wavFileNames){

                    // Nettoyage et explosion du nom de fichier
                    String wavFileName = wavFileNameObj.toString();

                    // Suppression de l'extension
                    wavFileName=wavFileName.substring(0, wavFileName.length()-4);

                    wavFileName=wavFileName.replaceAll("[.]", " ");
                    wavFileName=wavFileName.replaceAll("[_]", " ");
                    wavFileName=wavFileName.replaceAll("[ ]+", "/");
                    String[] nameSplit = wavFileName.split("/");

                    String instrumentName = new String();
                    int instrumentNoteIndex = -1;
                    String currentNote = new String();
                    Vector instrument;

                    // Parcours des parties du nom de fichier
                    groupNameVector = new Vector();
                    for (String part : nameSplit){
                        // Si une note est trouv√©e
                        currentNote=findNote(part,allNotesArray);
                        if (!currentNote.equals("none")){
                            // On stocke son index dans la table des notes
                            instrumentNoteIndex=allNotesArray.indexOf(currentNote);
                        }else{
                            // Sinon c'est qu'on est en pr√©sence d'un morceau du nom de l'instrument
                            groupNameVector.add(part);
                        }
                    }

                    // Implosion du nom de l'instrument
                    instrumentName=joinStrings(groupNameVector,"-");

                    // Si le nom du sample contient une note
                    if (instrumentNoteIndex>-1){
                        // Si la famille d'instruments existe, on la r√©cup√®re
                        if (instruments.containsKey(instrumentName)){
                            instrument = (Vector) instruments.get(instrumentName);
                            //appendLog("Known Instrument : "+instrumentName+ newline);
                        }else{
                        // Sinon, on instancie un vecteur pour regrouper cette nouvelle famille
                            instrument = new Vector();
                            appendLog("New Instrument : " + instrumentName+ newline);
                        }

                        // Creation d'un nouveau couple note-sample
                        Vector couple = new Vector();
                        couple.add(instrumentNoteIndex);
                        couple.add(wavFileNameObj.toString());
                        instrument.add(couple);
                        appendLog("Adding : " + wavFileNameObj.toString() + newline);
                        
                        // On dépose les informations de l'instrument dans le vecteur qui les regroupe tous
                        instruments.put(instrumentName, instrument);
                    }
                }


                // Affichage de chacune des entrées de la HashMap
                String instrumentName = new String();
                Set instrumentsFamily = instruments.keySet();
                Iterator i = instrumentsFamily.iterator();
                while (i.hasNext()){
                    instrumentName=i.next().toString();
                    Vector instrumentCouples = (Vector) instruments.get(instrumentName);
                    Iterator i2 = instrumentCouples.iterator();
                    while (i2.hasNext()){
                        Vector instrumentCouple = (Vector) i2.next();
                        //appendLog("Note id : "+instrumentCouple.get(0)+", sample : "+instrumentCouple.get(1)+newline);
                        //System.out.print("Note id : "+instrumentCouple.get(0)+" sample : "+instrumentCouple.get(1)+",");
                    }
                    //System.out.println();

                    // Construction et affichage du XML r√©sultant
                    buildXRNI(instrumentName,instrumentCouples,workingDirAbsolutePath);
                }
            }

            public String doInBackground() {
                try {
                    batch();
                }catch (Exception e) {
                    e.printStackTrace();
                }
                return null;
            }

            @Override
            public void done() {
                System.out.println("done");
            }
        };
        worker.execute();
    }//GEN-LAST:event_startButtonActionPerformed

    private void clearButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearButtonActionPerformed
        logTextArea.setText(null);
    }//GEN-LAST:event_clearButtonActionPerformed

    public static String[] getNotesArray(){
        return(notesArray);
    }

    public static Vector buildAllNotes(int startOctave, int endOctave){
        Vector localVector=new Vector();
        for(int i=startOctave;i<=endOctave;i++){
            for(int j=0;j<notesArray.length;j++){
                localVector.add(notesArray[j]+i);
            }

        }
        //System.out.println ("Nombre d'éléments : " + localVector.size());
        //System.out.println ("Taille du vecteur : " + localVector.capacity());
        return localVector;
    }

    public static String joinStrings (AbstractCollection<String> s, String d){
        if (s.isEmpty()) return "";
        Iterator<String> i=s.iterator();
        StringBuffer b = new StringBuffer(i.next());
        while (i.hasNext()){
            b.append(d).append(i.next());
        }
        return b.toString();
    }

    public static void main(String s[]) {
        // Instanciation of our class
        GroupToXRNI groupToXRNI = new GroupToXRNI();
        groupToXRNI.open();

        // Creation of a new frame
        JFrame f = new JFrame("GroupToXRNI");

        // Handling of close event
        f.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) { System.exit(0); }
        });
        f.getContentPane().add("Center", groupToXRNI);
        f.pack();
        Misc.initComponentSize(f);
    }

    // Search a note into a file name
    private String findNote(String fileName, Vector allNotesArray){
        String note;
        int index;
        for(Object noteObj : allNotesArray){
            note=noteObj.toString();
            index = fileName.indexOf(note);
            if (index!=-1) return(note);
        }
        return("none");
    }

    public void actionPerformed(ActionEvent e) {
        throw new UnsupportedOperationException("actionPerformed : Not supported yet.");
    }

    public void open() {
        Misc.initComponentSize(this);
    }

    public void close() {
        //throw new UnsupportedOperationException("close : Not supported yet.");
    }

    public void buildXRNI(String instrumentName, Vector couples, String workingDirAbsolutePath){
        // Initialisation du tableau des notes
        Vector allNotesArray = buildAllNotes(0,9);
        boolean success = false;

        String fileNames[] = new String[couples.size()+1];
        Element RenoiseInstrument = new Element("RenoiseInstrument");
        RenoiseInstrument.setAttribute("doc_version", "7");

        Element Name = new Element("Name");
        Name.setText(instrumentName);
        RenoiseInstrument.addContent(Name);

        Element SplitMap = new Element("SplitMap");
        RenoiseInstrument.addContent(SplitMap);

        appendLog("Building " + instrumentName + ".xrni" + newline);

        // Construction de la table de mapping
        int[] allNotesIndex = new int[allNotesArray.size()];

        // On remplit la table de mapping avec la valeur -1 signifiant aucune note
        for(int i = 0; i < allNotesIndex.length; i++){
            allNotesIndex[i] = -1;
        }

        // On parcourt tous les couples afin de déposer dans la table de mapping les notes concernées
        for(int i = 0; i < couples.size(); i++){
            Vector couple = (Vector) couples.get(i);
            int noteIndex = Integer.parseInt(couple.get(0).toString());
            // D√©p√¥t de la r√©f√©rence du sample dans la table de mapping
            allNotesIndex[noteIndex] = i;
            String sampleName = couple.get(1).toString();
        }

        // Remplissage du Mapping en montant
        int currentSampleIndex = -1;
        for(int i = 0; i < allNotesIndex.length; i++){
            currentSampleIndex = allNotesIndex[i] == -1 ? currentSampleIndex : allNotesIndex[i];
            allNotesIndex[i] = currentSampleIndex;
        }

        // Remplissage du Mapping en descendant
        for(int i = (allNotesIndex.length - 1); i >= 0; i--){
            currentSampleIndex = (allNotesIndex[i] == -1) ? currentSampleIndex : allNotesIndex[i];
            allNotesIndex[i] = currentSampleIndex;
        }

        // Création des éléments Split
        for(int i = 0; i < allNotesIndex.length; i++){
            Element Split = new Element("Split");
            Split.setText(String.valueOf(allNotesIndex[i]));
            SplitMap.addContent(Split);
        }

        // Visu du résultat:
        /*for(int i = 0; i < allNotesIndex.length; i++){
            appendLog(i + "," + allNotesIndex[i]);
        }*/

        Element Samples = new Element("Samples");
        RenoiseInstrument.addContent(Samples);

        for(int i = 0; i < couples.size(); i++){
            Vector couple = (Vector) couples.get(i);
            Element Sample = new Element("Sample");
            Samples.addContent(Sample);

            Element sampleName = new Element("Name");
            String nameString = couple.get(1).toString();
            nameString = nameString.substring(0, nameString.length() - 4);
            sampleName.setText(nameString);
            Sample.addContent(sampleName);

            Element BaseNote = new Element("BaseNote");
            Sample.addContent(BaseNote);
            BaseNote.setText(couple.get(0).toString());
        }
        XMLDocument = new Document(RenoiseInstrument);

        // Sauvegarde xml
        saveXML("Instrument.xml");

        // Nettoyage et création du dossier contenant les samples
        File SampleData = new File("SampleData");

        if (SampleData.isDirectory()){
            appendLog("Cleaning temporary files..." + newline);
            File[] SampleDataFiles = SampleData.listFiles();
            for(File SampleDataFile : SampleDataFiles){
                try{
                    success = SampleDataFile.delete();
                }
                catch(SecurityException e){
                    System.out.println("Exception de sécurité : "+e.toString());
                }
                if (success) appendLog(SampleDataFile.getName()+" deleted." + newline);
            }
            appendLog("...Done." + newline);
        }
        success = SampleData.mkdir();

        for(int i=0;i<couples.size();i++){
            int decimale=i/10;
            int unite=i%10;
            Vector couple = (Vector) couples.get(i);

            String sampleName = couple.get(1).toString();
            String fileNameParts[] = sampleName.split("[.]");

            // Un nom de fichier audio doit toujours être au format xxx.yyy, sinon on passe
            if (fileNameParts.length==2){
                String baseName = fileNameParts[0];
                String extension = fileNameParts[1];
                String dstFileName = "SampleData/Sample "+String.valueOf(decimale)+String.valueOf(unite)+"("+baseName+")."+extension;

                appendLog("Copy "+sampleName+" into temporary folder...");
                File src = new File(workingDirAbsolutePath+"/"+sampleName);
                File dst = new File(dstFileName);
                try {
                    success = copyFile(src, dst);
                } catch (IOException ex) {
                    Logger.getLogger(GroupToXRNI.class.getName()).log(Level.SEVERE, null, ex);
                }
                appendLog((success==true?"Done":"Error") + newline);

                fileNames[i+1]=dstFileName;
            }else{
                appendLog(sampleName+" is rejected." + newline);
            }
        }

        // Création de l'archive
        fileNames[0]="Instrument.xml";
        if (fileNames.length>1){
            appendLog("Adding files to archive." + newline);
            zipFile(fileNames,workingDirAbsolutePath+"/"+instrumentName+".xrni");
        }
        appendLog("Job is done!" + newline);
    }

    // Put the computed XML to disk
    public void saveXML(String fileName){
        try{
            XMLOutputter XMLOutput = new XMLOutputter(org.jdom.output.Format.getPrettyFormat());
            XMLOutput.output(XMLDocument, new FileOutputStream(fileName));
        }
        catch (java.io.IOException e){}
    }

    // Append log to text area
    private void appendLog(String text){
        logTextArea.append(text);
        logTextArea.setCaretPosition(logTextArea.getText().length());
    }

    // File copy function
    public boolean copyFile(File sourceFile, File destinationFile) throws IOException{
        boolean returnStatus=false;
        FileInputStream inputStream=null;
        FileOutputStream outputStream=null;
        try{
            byte buffer[]=new byte[512*1024];
            int readCount;
            inputStream=new FileInputStream(sourceFile);
            outputStream=new FileOutputStream(destinationFile);

            while((readCount=inputStream.read(buffer))!=-1){
                outputStream.write(buffer,0,readCount);
            }
            returnStatus=true;
        }catch(FileNotFoundException notFoundException){
            notFoundException.printStackTrace();
        }catch(IOException ioException){
            ioException.printStackTrace();
        }finally{
            try{
                inputStream.close();
            }catch(Exception e){
                e.printStackTrace();
            }
            try{
                outputStream.close();
            }catch(Exception e){
                e.printStackTrace();
            }
        }
        return returnStatus;
    }

    // File zipping function
    public void zipFile(String[] filenames, String outFilename){

        // Create a buffer for reading the files
        byte[] buf = new byte[1024];

        try {
            // Create the ZIP file
            ZipOutputStream out = new ZipOutputStream(new FileOutputStream(outFilename));

            // Compress the files
            appendLog("Archive file : " + outFilename + newline);
            appendLog("Number of files to compress : "+filenames.length + newline);
            for (int i=0; i<filenames.length; i++) {
                FileInputStream in = new FileInputStream(filenames[i]);

                // Add ZIP entry to output stream.
                out.putNextEntry(new ZipEntry(filenames[i]));

                // Transfer bytes from the file to the ZIP file
                int len;
                while ((len = in.read(buf)) > 0) {
                    out.write(buf, 0, len);
                }

                // Complete the entry
                out.closeEntry();
                in.close();
            }

            // Complete the ZIP file
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton clearButton;
    private javax.swing.JButton directoryButton;
    private javax.swing.JTextField directoryField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea logTextArea;
    private javax.swing.JButton startButton;
    // End of variables declaration//GEN-END:variables
}
